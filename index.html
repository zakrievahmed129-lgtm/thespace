<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OdyssÃ©e Spatiale Pro - Ahmed Edition Ultime</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00f0ff;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.7);
            z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 10, 20, 0.9);
            backdrop-filter: blur(15px);
            padding: 15px;
            border-left: 4px solid #00f0ff;
            border-radius: 0 10px 10px 0;
            border: 1px solid rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
        }

        #health-container {
            width: 220px;
            height: 14px;
            background: rgba(255, 0, 0, 0.1);
            margin-top: 10px;
            border: 1px solid rgba(255, 50, 50, 0.5);
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4d4d);
            box-shadow: 0 0 15px #ff0000;
            transition: width 0.2s ease-out;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 44px;
            height: 44px;
            border: 2px solid rgba(0, 240, 255, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #00f0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #prompt {
            position: absolute;
            top: 80%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: bold;
            font-size: 1.4rem;
            text-shadow: 0 0 15px #00f0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(0, 240, 255, 0.5);
        }

        #fade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            transition: opacity 0.8s;
        }

        #damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: background 0.1s;
            z-index: 99;
        }

        #mission-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 170, 0, 0.15);
            backdrop-filter: blur(15px);
            padding: 15px;
            border-right: 4px solid #ffaa00;
            border-radius: 10px 0 0 10px;
            border: 1px solid rgba(255, 170, 0, 0.3);
            color: #ffaa00;
            max-width: 300px;
            display: none;
            z-index: 10;
        }

        .mission-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.7);
        }

        .mission-desc {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .mission-progress {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .mission-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            box-shadow: 0 0 10px #ffaa00;
            transition: width 0.3s;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 240, 255, 0.2);
            backdrop-filter: blur(15px);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid #00f0ff;
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.5);
        }

        /* Cinematic Intro Styles */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.5s ease;
        }

        #intro-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .intro-title {
            font-size: 4rem;
            font-weight: bold;
            color: #00f0ff;
            text-shadow: 0 0 60px #00f0ff, 0 0 100px #00f0ff;
            letter-spacing: 15px;
            animation: titleGlow 2s ease-in-out infinite alternate;
            opacity: 0;
            animation: fadeInUp 2s ease forwards 0.5s, titleGlow 2s ease-in-out infinite alternate 2.5s;
        }

        .intro-subtitle {
            font-size: 1.5rem;
            color: #ffaa00;
            letter-spacing: 8px;
            margin-top: 20px;
            opacity: 0;
            animation: fadeInUp 2s ease forwards 1.5s;
        }

        .intro-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        .intro-ship {
            position: absolute;
            width: 80px;
            height: 30px;
            bottom: -100px;
            opacity: 0;
            animation: shipFlyIn 3s ease-out forwards 2.5s;
        }

        .intro-ship::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00f0ff 0%, transparent 100%);
            clip-path: polygon(0 50%, 100% 0, 100% 100%);
            filter: drop-shadow(0 0 20px #00f0ff);
        }

        .intro-ship::after {
            content: '';
            position: absolute;
            left: -40px;
            top: 5px;
            width: 40px;
            height: 20px;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            border-radius: 50%;
            filter: blur(8px);
            animation: enginePulse 0.3s ease-in-out infinite alternate;
        }

        .press-start {
            position: absolute;
            bottom: 15%;
            font-size: 1.2rem;
            color: #fff;
            letter-spacing: 5px;
            opacity: 0;
            animation: fadeInUp 1s ease forwards 4s, blink 1s ease-in-out infinite 5s;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 60px #00f0ff, 0 0 100px #00f0ff;
            }

            to {
                text-shadow: 0 0 80px #00f0ff, 0 0 150px #00f0ff, 0 0 200px #0088ff;
            }
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        @keyframes shipFlyIn {
            0% {
                bottom: -100px;
                left: 10%;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                bottom: 50%;
                left: 60%;
                opacity: 0;
            }
        }

        @keyframes enginePulse {
            from {
                width: 40px;
                opacity: 0.8;
            }

            to {
                width: 60px;
                opacity: 1;
            }
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Landing Cinematic */
        #landing-cinematic {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 500;
            pointer-events: none;
            display: none;
        }

        .landing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.8) 100%);
        }

        .friction-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .friction-line {
            position: absolute;
            width: 3px;
            height: 100px;
            background: linear-gradient(to bottom, transparent, #ff6600, #ffaa00, transparent);
            animation: frictionFall 0.5s linear infinite;
            opacity: 0;
        }

        @keyframes frictionFall {
            from {
                transform: translateY(-100px);
                opacity: 0.8;
            }

            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        .landing-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 30px #ff6600;
            letter-spacing: 10px;
            opacity: 0;
        }

        .landing-text.show {
            animation: landingTextPulse 2s ease-in-out;
        }

        @keyframes landingTextPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .heat-glow {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, rgba(255, 100, 0, 0.4), transparent);
            opacity: 0;
        }
    </style>
</head>

<body>

    <div id="damage-overlay"></div>
    <div id="hud">
        <div class="hud-panel">
            <div id="gameMode" style="font-weight: bold; letter-spacing: 3px; color: #00f0ff;">COMMANDANT AHMED</div>
            <div id="location" style="opacity: 0.9; font-size: 0.85rem; margin-top: 4px;">SYNCHRONISATION...</div>
            <div id="questStatus" style="color: #ffaa00; font-weight: bold; margin-top: 8px; font-size: 0.8rem;">SCAN
                SECTEUR</div>
            <div id="health-container">
                <div id="health-bar"></div>
            </div>
            <div id="score" style="margin-top: 10px; color: #ffaa00; font-size: 14px;">PRIME : 0</div>
        </div>
    </div>

    <div id="mission-panel">
        <div class="mission-title">ðŸŽ¯ MISSION ACTIVE</div>
        <div class="mission-desc" id="mission-desc"></div>
        <div class="mission-progress">
            <div class="mission-progress-bar" id="mission-progress-bar"></div>
        </div>
    </div>

    <div id="notification"></div>
    <div id="prompt"></div>
    <div id="crosshair"></div>
    <div id="fade"></div>

    <!-- Intro Cinematic -->
    <div id="intro-screen">
        <div class="intro-stars" id="intro-stars"></div>
        <div class="intro-title">ODYSSÃ‰E SPATIALE</div>
        <div class="intro-subtitle">AHMED EDITION ULTIME</div>
        <div class="intro-ship"></div>
        <div class="press-start">CLIQUEZ POUR COMMENCER</div>
    </div>

    <!-- Landing Cinematic -->
    <div id="landing-cinematic">
        <div class="landing-overlay"></div>
        <div class="friction-lines" id="friction-lines"></div>
        <div class="heat-glow" id="heat-glow"></div>
        <div class="landing-text" id="landing-text">ENTRÃ‰E ATMOSPHÃ‰RIQUE</div>
    </div>

    <script>
        let scene, camera, renderer, clock;
        let isLocked = false, currentMode = 'SPACE';
        let ship, stars, currentPlanetObj, planetEnvironment, engineFlames = [];
        let planets = [];
        let enemies = [];
        let health = 100, score = 0;
        let keys = {};
        const shipRot = { yaw: 0, pitch: 0 };
        const playerRot = { yaw: 0, pitch: 0 };

        // SystÃ¨me de missions
        let currentMission = null;
        let missionObjects = [];
        let collectedItems = 0;

        // Cinematic states
        let gameStarted = false;
        let isInCinematic = false;

        // --- TEXTURES ULTRA HD PROCÃ‰DURALES ---
        function createMetallicTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 2048;
            const ctx = canvas.getContext('2d');

            // Base mÃ©tallique
            const gradient = ctx.createLinearGradient(0, 0, 2048, 2048);
            gradient.addColorStop(0, '#666666');
            gradient.addColorStop(0.5, '#999999');
            gradient.addColorStop(1, '#555555');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 2048, 2048);

            // Rayures mÃ©talliques
            for (let i = 0; i < 200; i++) {
                ctx.strokeStyle = `rgba(${Math.random() > 0.5 ? 200 : 100}, ${Math.random() > 0.5 ? 200 : 100}, ${Math.random() > 0.5 ? 200 : 100}, 0.3)`;
                ctx.lineWidth = Math.random() * 3;
                ctx.beginPath();
                ctx.moveTo(Math.random() * 2048, Math.random() * 2048);
                ctx.lineTo(Math.random() * 2048, Math.random() * 2048);
                ctx.stroke();
            }

            // Reflets
            for (let i = 0; i < 50; i++) {
                const grd = ctx.createRadialGradient(
                    Math.random() * 2048, Math.random() * 2048, 0,
                    Math.random() * 2048, Math.random() * 2048, Math.random() * 300
                );
                grd.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 2048, 2048);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createPlanetTexture(baseColor, isGround = false) {
            const size = isGround ? 2048 : 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Couleur de base avec dÃ©gradÃ©
            const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size);
            grad.addColorStop(0, baseColor);
            grad.addColorStop(1, adjustColor(baseColor, -30));
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);

            // CratÃ¨res et formations
            for (let i = 0; i < 80; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const r = Math.random() * (isGround ? 300 : 150);
                const crater = ctx.createRadialGradient(x, y, 0, x, y, r);
                crater.addColorStop(0, `rgba(0,0,0,${Math.random() * 0.5})`);
                crater.addColorStop(0.7, `rgba(0,0,0,${Math.random() * 0.2})`);
                crater.addColorStop(1, 'transparent');
                ctx.fillStyle = crater;
                ctx.fillRect(0, 0, size, size);
            }

            // DÃ©tails de surface
            for (let i = 0; i < 6000; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const s = Math.random() * 5;
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.08)';
                ctx.fillRect(x, y, s, s);
            }

            // Veines minÃ©rales
            for (let i = 0; i < 100; i++) {
                ctx.strokeStyle = `rgba(${Math.random() * 100}, ${Math.random() * 100}, ${Math.random() * 255}, 0.3)`;
                ctx.lineWidth = Math.random() * 4;
                ctx.beginPath();
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                ctx.moveTo(startX, startY);
                for (let j = 0; j < 5; j++) {
                    ctx.lineTo(startX + (Math.random() - 0.5) * 200, startY + (Math.random() - 0.5) * 200);
                }
                ctx.stroke();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            if (isGround) tex.repeat.set(4, 4);
            tex.anisotropy = 16;
            return tex;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Generate stars for intro screen
        function generateIntroStars() {
            const container = document.getElementById('intro-stars');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                const size = Math.random() * 4 + 1;
                star.style.width = star.style.height = size + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                // Some stars are brighter
                if (Math.random() > 0.9) {
                    star.style.boxShadow = '0 0 ' + (size * 3) + 'px #00f0ff';
                }
                container.appendChild(star);
            }
        }

        // Start intro cinematic
        function startIntroCinematic() {
            generateIntroStars();

            // Hide game UI during intro
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';

            // Click to start
            document.getElementById('intro-screen').addEventListener('click', () => {
                if (!gameStarted) {
                    gameStarted = true;
                    document.getElementById('intro-screen').classList.add('hidden');

                    // Play epic fly-through cinematic
                    playEpicIntroCinematic();
                }
            });
        }

        // EPIC INTRO CINEMATIC - Multiple phases with dramatic camera work
        function playEpicIntroCinematic() {
            isInCinematic = true;

            // Create warp speed particles
            const warpParticleCount = 500;
            const warpGeo = new THREE.BufferGeometry();
            const warpPositions = new Float32Array(warpParticleCount * 3);
            const warpVelocities = [];

            for (let i = 0; i < warpParticleCount; i++) {
                warpPositions[i * 3] = (Math.random() - 0.5) * 2000;
                warpPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                warpPositions[i * 3 + 2] = (Math.random() - 0.5) * 5000;
                warpVelocities.push(Math.random() * 50 + 20);
            }
            warpGeo.setAttribute('position', new THREE.BufferAttribute(warpPositions, 3));

            const warpMat = new THREE.PointsMaterial({
                color: 0x00f0ff,
                size: 3,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            const warpParticles = new THREE.Points(warpGeo, warpMat);
            scene.add(warpParticles);

            // Create lens flare effect mesh
            const flareGeo = new THREE.PlaneGeometry(500, 500);
            const flareMat = new THREE.MeshBasicMaterial({
                color: 0x00f0ff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const lensFlare = new THREE.Mesh(flareGeo, flareMat);
            scene.add(lensFlare);

            // Position ship far away
            ship.position.set(-5000, 1000, -8000);
            ship.rotation.set(0, Math.PI * 0.3, 0);

            // Cinematic timing
            let cinematicStart = 0;
            const totalDuration = 12000; // 12 seconds epic intro

            // Camera keyframes for different phases
            const phases = [
                { name: 'SPACE_PAN', start: 0, end: 0.15 },        // Pan across space
                { name: 'SHIP_REVEAL', start: 0.15, end: 0.35 },   // Reveal ship from distance
                { name: 'FLYBY', start: 0.35, end: 0.55 },         // Dramatic flyby
                { name: 'WARP_SPEED', start: 0.55, end: 0.75 },    // Warp speed effect
                { name: 'ARRIVAL', start: 0.75, end: 1.0 }         // Arrive at starting position
            ];

            function animateIntro(timestamp) {
                if (cinematicStart === 0) cinematicStart = timestamp;
                const elapsed = timestamp - cinematicStart;
                const progress = Math.min(elapsed / totalDuration, 1);

                // Easing functions
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeOut = t => 1 - Math.pow(1 - t, 3);

                // Update warp particles
                const warpPositionsArray = warpParticles.geometry.attributes.position.array;
                for (let i = 0; i < warpParticleCount; i++) {
                    warpPositionsArray[i * 3 + 2] += warpVelocities[i];
                    if (warpPositionsArray[i * 3 + 2] > 3000) {
                        warpPositionsArray[i * 3 + 2] = -3000;
                        warpPositionsArray[i * 3] = (Math.random() - 0.5) * 2000;
                        warpPositionsArray[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                    }
                }
                warpParticles.geometry.attributes.position.needsUpdate = true;

                // PHASE 1: Space Pan - Camera slowly pans across the starfield
                if (progress < phases[0].end) {
                    const phaseProgress = progress / phases[0].end;
                    camera.position.set(
                        -8000 + phaseProgress * 2000,
                        2000 - phaseProgress * 500,
                        5000
                    );
                    camera.lookAt(new THREE.Vector3(0, 0, -5000));

                    // Ship is hidden initially
                    ship.visible = false;
                }
                // PHASE 2: Ship Reveal - Ship comes into view
                else if (progress < phases[1].end) {
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const eased = easeOut(phaseProgress);

                    ship.visible = true;
                    ship.position.set(
                        -5000 + eased * 3000,
                        1000 - eased * 500,
                        -8000 + eased * 4000
                    );

                    camera.position.set(
                        ship.position.x + 800 - eased * 400,
                        ship.position.y + 200,
                        ship.position.z + 1000
                    );
                    camera.lookAt(ship.position);

                    // Animate engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1.2 + Math.sin(elapsed * 0.015 + i) * 0.4);
                    });
                }
                // PHASE 3: Dramatic Flyby - Camera does a dramatic orbit around ship
                else if (progress < phases[2].end) {
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const eased = easeInOut(phaseProgress);

                    // Ship continues moving
                    ship.position.set(
                        -2000 + eased * 1500,
                        500 + Math.sin(eased * Math.PI) * 200,
                        -4000 + eased * 2500
                    );
                    ship.rotation.y = Math.PI * 0.3 - eased * 0.4;

                    // Camera orbits around ship
                    const orbitAngle = phaseProgress * Math.PI * 0.8;
                    camera.position.set(
                        ship.position.x + Math.cos(orbitAngle) * 300,
                        ship.position.y + 50 + Math.sin(orbitAngle * 2) * 100,
                        ship.position.z + Math.sin(orbitAngle) * 400 + 200
                    );
                    camera.lookAt(ship.position);

                    // Engine flames intensify
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1.5 + Math.sin(elapsed * 0.02 + i) * 0.5);
                    });
                }
                // PHASE 4: Warp Speed - Dramatic speed effect
                else if (progress < phases[3].end) {
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const eased = easeInOut(phaseProgress);

                    // Warp particles become visible and stretch
                    warpMat.opacity = Math.sin(phaseProgress * Math.PI) * 0.8;
                    warpParticles.position.copy(ship.position);

                    // Ship accelerates dramatically
                    ship.position.set(
                        -500 + eased * 400,
                        500 + eased * -400,
                        -1500 + eased * 2800
                    );
                    ship.rotation.y = Math.PI * -0.1;

                    // Camera behind ship for warp effect
                    camera.position.set(
                        ship.position.x,
                        ship.position.y + 30,
                        ship.position.z + 150
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, 0, -500)));

                    // Lens flare effect
                    lensFlare.position.copy(camera.position).add(new THREE.Vector3(0, 0, -200));
                    lensFlare.lookAt(camera.position);
                    flareMat.opacity = Math.sin(phaseProgress * Math.PI) * 0.3;

                    // Maximum engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(2.5 + Math.sin(elapsed * 0.03 + i) * 0.8);
                    });

                    // Camera FOV change for speed effect
                    camera.fov = 70 + Math.sin(phaseProgress * Math.PI) * 20;
                    camera.updateProjectionMatrix();
                }
                // PHASE 5: Arrival - Slow down and settle at starting position
                else {
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);

                    // Fade out warp particles
                    warpMat.opacity = (1 - eased) * 0.5;
                    flareMat.opacity = 0;

                    // Ship slows down
                    ship.position.set(
                        -100 + eased * 100,
                        100 + eased * -100,
                        1300 + eased * 200
                    );
                    ship.rotation.set(0, 0, 0);

                    // Camera settles behind ship
                    const targetCamPos = ship.position.clone().add(new THREE.Vector3(0, 15, 65));
                    camera.position.lerp(targetCamPos, 0.08);
                    camera.lookAt(ship.position);

                    // Reset FOV
                    camera.fov = 70 + (1 - eased) * 10;
                    camera.updateProjectionMatrix();

                    // Normal engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1 + (1 - eased) * 1.5 + Math.sin(elapsed * 0.01 + i) * 0.3);
                    });
                }

                renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateIntro);
                } else {
                    // Cleanup
                    scene.remove(warpParticles);
                    scene.remove(lensFlare);
                    warpGeo.dispose();
                    warpMat.dispose();
                    flareGeo.dispose();
                    flareMat.dispose();

                    // Reset camera FOV
                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    isInCinematic = false;
                    ship.visible = true;
                    document.getElementById('hud').style.opacity = '1';
                    document.getElementById('crosshair').style.opacity = '1';
                    document.getElementById('hud').style.transition = 'opacity 1s';
                    document.getElementById('crosshair').style.transition = 'opacity 1s';
                }
            }

            requestAnimationFrame(animateIntro);
        }

        // Landing cinematic - ULTRA EPIC 3D CINEMATIC
        let landingParticles = null;
        let reentryGlow = null;
        let atmosphericClouds = null;
        let fireTrail = null;

        function playLandingCinematic(planet, callback) {
            isInCinematic = true;

            const landingDiv = document.getElementById('landing-cinematic');
            const landingText = document.getElementById('landing-text');
            const heatGlow = document.getElementById('heat-glow');

            landingDiv.style.display = 'block';

            // Hide UI during cinematic
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';
            document.getElementById('prompt').style.opacity = '0';

            // Position ship high above the planet for cinematic entry
            const planetPos = planet.position.clone();
            const startHeight = planet.userData.size + 4000;
            const approachAngle = Math.random() * Math.PI * 2;

            ship.scale.set(1, 1, 1);
            ship.position.set(
                planetPos.x + Math.cos(approachAngle) * 800,
                planetPos.y + startHeight,
                planetPos.z + Math.sin(approachAngle) * 800
            );
            ship.rotation.set(1.0, approachAngle, 0.15); // Steeper nose down for dramatic reentry

            // Create massive reentry particle effects
            const particleCount = 400;
            const particleGeo = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = (Math.random() - 0.5) * 80;
                particlePositions[i * 3 + 1] = Math.random() * 200;
                particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
                // Orange to yellow gradient
                particleColors[i * 3] = 1.0;
                particleColors[i * 3 + 1] = 0.3 + Math.random() * 0.5;
                particleColors[i * 3 + 2] = 0;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMat = new THREE.PointsMaterial({
                size: 6,
                transparent: true,
                opacity: 0.9,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            landingParticles = new THREE.Points(particleGeo, particleMat);
            scene.add(landingParticles);

            // Create multiple reentry glow layers
            const glowGeo = new THREE.SphereGeometry(40, 24, 24);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.5,
                side: THREE.BackSide
            });
            reentryGlow = new THREE.Mesh(glowGeo, glowMat);
            scene.add(reentryGlow);

            // Outer corona glow
            const coronaGeo = new THREE.SphereGeometry(60, 16, 16);
            const coronaMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const coronaGlow = new THREE.Mesh(coronaGeo, coronaMat);
            scene.add(coronaGlow);

            // Create fire trail behind ship
            const trailCount = 100;
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(trailCount * 3);
            for (let i = 0; i < trailCount; i++) {
                trailPositions[i * 3] = 0;
                trailPositions[i * 3 + 1] = i * 3;
                trailPositions[i * 3 + 2] = 0;
            }
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMat = new THREE.PointsMaterial({
                color: 0xff2200,
                size: 8,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            fireTrail = new THREE.Points(trailGeo, trailMat);
            scene.add(fireTrail);

            // Cinematic timing - Extended to 10 seconds
            let cinematicStartTime = 0;
            const totalDuration = 10000;

            // 5 Camera phases for epic landing
            const phases = [
                { name: 'SPACE_VIEW', start: 0, end: 0.15 },        // View from space with planet below
                { name: 'ATMOSPHERE_ENTRY', start: 0.15, end: 0.35 }, // Dramatic atmospheric entry
                { name: 'FIREBALL', start: 0.35, end: 0.55 },        // Ship is a fireball
                { name: 'CLOUD_BREAK', start: 0.55, end: 0.75 },     // Breaking through clouds
                { name: 'FINAL_DESCENT', start: 0.75, end: 1.0 }     // Landing sequence
            ];

            // Show text phases
            landingText.textContent = 'ðŸ›¸ APPROCHE ORBITALE';
            landingText.classList.add('show');

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸ”¥ ENTRÃ‰E ATMOSPHÃ‰RIQUE';
                landingText.classList.add('show');
                heatGlow.style.transition = 'opacity 0.3s';
                heatGlow.style.opacity = '0.7';
            }, 1500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸŒ ' + planet.userData.name;
                landingText.classList.add('show');
            }, 3500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'â˜ï¸ TRAVERSÃ‰E NUAGEUSE';
                landingText.classList.add('show');
                heatGlow.style.opacity = '0.3';
            }, 5500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'âœ… ATTERRISSAGE';
                landingText.classList.add('show');
                heatGlow.style.opacity = '0';
            }, 7500);

            function animateLanding(timestamp) {
                if (cinematicStartTime === 0) cinematicStartTime = timestamp;
                const elapsed = timestamp - cinematicStartTime;
                const progress = Math.min(elapsed / totalDuration, 1);

                // Easing functions
                const easeOut = t => 1 - Math.pow(1 - t, 3);
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeIn = t => t * t * t;

                // Ship descends with dramatic curve
                const descentProgress = easeInOut(progress);
                const currentHeight = startHeight - (descentProgress * (startHeight - 80));
                const spiralAngle = approachAngle + progress * Math.PI * 0.5;
                const spiralRadius = 800 * (1 - descentProgress * 0.9);

                ship.position.set(
                    planetPos.x + Math.cos(spiralAngle) * spiralRadius,
                    planetPos.y + currentHeight,
                    planetPos.z + Math.sin(spiralAngle) * spiralRadius
                );

                // Ship gradually levels out
                const pitchAngle = 1.0 - (easeOut(progress) * 1.0);
                ship.rotation.x = pitchAngle;
                ship.rotation.y = spiralAngle + Math.PI;
                ship.rotation.z = Math.sin(elapsed * 0.003) * 0.08 * (1 - progress);

                // Update main particles
                landingParticles.position.copy(ship.position);
                landingParticles.position.y += 30;
                landingParticles.rotation.y += 0.02;

                const positions = landingParticles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] += 8;
                    if (positions[i * 3 + 1] > 250) {
                        positions[i * 3 + 1] = 0;
                        positions[i * 3] = (Math.random() - 0.5) * 80;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 80;
                    }
                }
                landingParticles.geometry.attributes.position.needsUpdate = true;
                particleMat.opacity = Math.max(0, 0.9 - progress * 1.3);

                // Update fire trail
                fireTrail.position.copy(ship.position);
                fireTrail.position.y += 50;
                fireTrail.rotation.x = -pitchAngle;
                trailMat.opacity = Math.max(0, 0.7 - progress * 1.0);

                // Update glows
                reentryGlow.position.copy(ship.position);
                glowMat.opacity = Math.max(0, 0.6 - progress * 0.9);
                reentryGlow.scale.setScalar(1 + Math.sin(elapsed * 0.015) * 0.3);

                coronaGlow.position.copy(ship.position);
                coronaMat.opacity = Math.max(0, 0.3 - progress * 0.5);
                coronaGlow.scale.setScalar(1.5 + Math.sin(elapsed * 0.01) * 0.4);

                // EPIC CINEMATIC CAMERA WORK - 5 Phases
                if (progress < phases[0].end) {
                    // Phase 1: Space view - Camera far away, shows ship approaching planet
                    const phaseProgress = progress / phases[0].end;
                    const camDist = 2000 - phaseProgress * 500;
                    camera.position.set(
                        planetPos.x + camDist * 0.7,
                        planetPos.y + startHeight * 0.5 + phaseProgress * 500,
                        planetPos.z + camDist
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[1].end) {
                    // Phase 2: Atmospheric entry - Dramatic side angle
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const orbitAngle = phaseProgress * Math.PI * 0.4;
                    camera.position.set(
                        ship.position.x + Math.cos(orbitAngle + spiralAngle) * 400,
                        ship.position.y + 150 - phaseProgress * 50,
                        ship.position.z + Math.sin(orbitAngle + spiralAngle) * 400
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 65 + phaseProgress * 10;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[2].end) {
                    // Phase 3: Fireball - Close chase camera
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const camOffset = new THREE.Vector3(0, 60 + Math.sin(phaseProgress * Math.PI) * 30, 120);
                    camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), ship.rotation.y);
                    camera.position.lerp(ship.position.clone().add(camOffset), 0.08);
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, -30, 0)));
                    camera.fov = 75;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[3].end) {
                    // Phase 4: Cloud break - Dramatic flyby
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const flybyAngle = phaseProgress * Math.PI * 0.6;
                    camera.position.set(
                        ship.position.x + Math.sin(flybyAngle) * 200,
                        ship.position.y - 50 + Math.cos(flybyAngle * 2) * 80,
                        ship.position.z + Math.cos(flybyAngle) * 250
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 70 - phaseProgress * 5;
                    camera.updateProjectionMatrix();
                }
                else {
                    // Phase 5: Final descent - Low angle hero shot
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    camera.position.set(
                        ship.position.x + 80 * (1 - eased * 0.5),
                        ship.position.y - 60 + eased * 100,
                        ship.position.z + 120 - eased * 30
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 65 + eased * 5;
                    camera.updateProjectionMatrix();
                }

                // Intense camera shake during atmospheric phases
                if (progress > 0.15 && progress < 0.7) {
                    const intensity = Math.sin((progress - 0.15) / 0.55 * Math.PI) * 5;
                    camera.position.x += (Math.random() - 0.5) * intensity;
                    camera.position.y += (Math.random() - 0.5) * intensity;
                    camera.position.z += (Math.random() - 0.5) * intensity * 0.5;
                }

                // Animate engine flames with intensity
                const flameIntensity = 1 + (1 - progress) * 2;
                engineFlames.forEach((f, i) => {
                    f.scale.setScalar(flameIntensity + Math.sin(elapsed * 0.025 + i) * 0.6);
                });

                renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateLanding);
                } else {
                    // Cleanup all cinematic elements
                    scene.remove(landingParticles);
                    scene.remove(reentryGlow);
                    scene.remove(coronaGlow);
                    scene.remove(fireTrail);

                    landingParticles.geometry.dispose();
                    landingParticles.material.dispose();
                    reentryGlow.geometry.dispose();
                    reentryGlow.material.dispose();
                    coronaGlow.geometry.dispose();
                    coronaMat.dispose();
                    fireTrail.geometry.dispose();
                    fireTrail.material.dispose();

                    landingParticles = null;
                    reentryGlow = null;
                    fireTrail = null;

                    // Reset camera FOV
                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    setTimeout(() => {
                        landingDiv.style.display = 'none';
                        landingText.classList.remove('show');
                        document.getElementById('hud').style.opacity = '1';
                        document.getElementById('crosshair').style.opacity = '1';
                        document.getElementById('prompt').style.opacity = '1';
                        isInCinematic = false;
                        if (callback) callback();
                    }, 500);
                }
            }

            requestAnimationFrame(animateLanding);
        }

        // TAKEOFF CINEMATIC - Epic departure from planet
        function playTakeoffCinematic(callback) {
            isInCinematic = true;

            const landingDiv = document.getElementById('landing-cinematic');
            const landingText = document.getElementById('landing-text');
            const heatGlow = document.getElementById('heat-glow');

            landingDiv.style.display = 'block';

            // Hide UI during cinematic
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';
            document.getElementById('prompt').style.opacity = '0';
            document.getElementById('mission-panel').style.display = 'none';

            // Store starting position (on planet surface)
            const startPos = ship.position.clone();
            const targetHeight = 3000;

            // Create takeoff particle effects (dust/thrust)
            const dustCount = 300;
            const dustGeo = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = [];

            for (let i = 0; i < dustCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 100;
                dustPositions[i * 3] = Math.cos(angle) * dist;
                dustPositions[i * 3 + 1] = Math.random() * 20;
                dustPositions[i * 3 + 2] = Math.sin(angle) * dist;
                dustVelocities.push({
                    x: (Math.random() - 0.5) * 3,
                    y: Math.random() * 2 + 1,
                    z: (Math.random() - 0.5) * 3
                });
            }
            dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

            const dustMat = new THREE.PointsMaterial({
                color: currentPlanetObj.userData.atmosphereColor,
                size: 5,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const dustParticles = new THREE.Points(dustGeo, dustMat);
            dustParticles.position.copy(startPos);
            scene.add(dustParticles);

            // Create engine exhaust
            const exhaustCount = 150;
            const exhaustGeo = new THREE.BufferGeometry();
            const exhaustPositions = new Float32Array(exhaustCount * 3);

            for (let i = 0; i < exhaustCount; i++) {
                exhaustPositions[i * 3] = (Math.random() - 0.5) * 30;
                exhaustPositions[i * 3 + 1] = -Math.random() * 100;
                exhaustPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;
            }
            exhaustGeo.setAttribute('position', new THREE.BufferAttribute(exhaustPositions, 3));

            const exhaustMat = new THREE.PointsMaterial({
                color: 0x00f0ff,
                size: 6,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const exhaustParticles = new THREE.Points(exhaustGeo, exhaustMat);
            scene.add(exhaustParticles);

            // Create speed lines for atmosphere escape
            const speedLineCount = 100;
            const speedGeo = new THREE.BufferGeometry();
            const speedPositions = new Float32Array(speedLineCount * 6); // Lines have 2 points each

            for (let i = 0; i < speedLineCount; i++) {
                const x = (Math.random() - 0.5) * 500;
                const z = (Math.random() - 0.5) * 500;
                speedPositions[i * 6] = x;
                speedPositions[i * 6 + 1] = Math.random() * 200;
                speedPositions[i * 6 + 2] = z;
                speedPositions[i * 6 + 3] = x;
                speedPositions[i * 6 + 4] = speedPositions[i * 6 + 1] + 50;
                speedPositions[i * 6 + 5] = z;
            }
            speedGeo.setAttribute('position', new THREE.BufferAttribute(speedPositions, 3));

            const speedMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            const speedLines = new THREE.LineSegments(speedGeo, speedMat);
            scene.add(speedLines);

            // Cinematic timing
            let cinematicStart = 0;
            const totalDuration = 8000;

            const phases = [
                { name: 'POWER_UP', start: 0, end: 0.15 },
                { name: 'LIFTOFF', start: 0.15, end: 0.35 },
                { name: 'ASCENT', start: 0.35, end: 0.6 },
                { name: 'ESCAPE', start: 0.6, end: 0.85 },
                { name: 'SPACE', start: 0.85, end: 1.0 }
            ];

            // Text phases
            landingText.textContent = 'âš¡ MISE SOUS TENSION';
            landingText.classList.add('show');

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸš€ DÃ‰COLLAGE';
                landingText.classList.add('show');
            }, 1200);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'â˜ï¸ SORTIE ATMOSPHÃ‰RIQUE';
                landingText.classList.add('show');
            }, 2800);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸŒŒ ESPACE PROFOND';
                landingText.classList.add('show');
            }, 5000);

            function animateTakeoff(timestamp) {
                if (cinematicStart === 0) cinematicStart = timestamp;
                const elapsed = timestamp - cinematicStart;
                const progress = Math.min(elapsed / totalDuration, 1);

                const easeIn = t => t * t * t;
                const easeOut = t => 1 - Math.pow(1 - t, 3);
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // Ship movement
                if (progress < phases[0].end) {
                    // Power up - ship vibrates
                    const phaseProgress = progress / phases[0].end;
                    const shake = phaseProgress * 0.5;
                    ship.position.x = startPos.x + (Math.random() - 0.5) * shake;
                    ship.position.z = startPos.z + (Math.random() - 0.5) * shake;
                    ship.position.y = startPos.y + phaseProgress * 5;
                }
                else if (progress < phases[1].end) {
                    // Liftoff - slow rise
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const eased = easeIn(phaseProgress);
                    ship.position.y = startPos.y + 5 + eased * 200;
                    ship.rotation.x = -eased * 0.3;
                }
                else if (progress < phases[2].end) {
                    // Ascent - accelerating
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const eased = easeInOut(phaseProgress);
                    ship.position.y = startPos.y + 205 + eased * 1000;
                    ship.rotation.x = -0.3 - eased * 0.5;
                }
                else if (progress < phases[3].end) {
                    // Escape - breaking atmosphere
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const eased = easeIn(phaseProgress);
                    ship.position.y = startPos.y + 1205 + eased * 1500;
                    ship.rotation.x = -0.8 - eased * 0.2;
                    speedMat.opacity = phaseProgress * 0.5;
                }
                else {
                    // Space - final position
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    ship.position.y = startPos.y + 2705 + eased * 300;
                    ship.rotation.x = -1 + eased * 1;
                    speedMat.opacity = (1 - eased) * 0.5;
                }

                // Update dust particles (ground effect)
                if (progress < 0.4) {
                    const dustArray = dustParticles.geometry.attributes.position.array;
                    for (let i = 0; i < dustCount; i++) {
                        dustArray[i * 3] += dustVelocities[i].x * (1 - progress * 2);
                        dustArray[i * 3 + 1] += dustVelocities[i].y;
                        dustArray[i * 3 + 2] += dustVelocities[i].z * (1 - progress * 2);
                    }
                    dustParticles.geometry.attributes.position.needsUpdate = true;
                    dustMat.opacity = Math.max(0, 0.6 - progress * 2);
                }

                // Update exhaust
                exhaustParticles.position.copy(ship.position);
                const exhaustArray = exhaustParticles.geometry.attributes.position.array;
                for (let i = 0; i < exhaustCount; i++) {
                    exhaustArray[i * 3 + 1] -= 10;
                    if (exhaustArray[i * 3 + 1] < -150) {
                        exhaustArray[i * 3 + 1] = 0;
                        exhaustArray[i * 3] = (Math.random() - 0.5) * 30;
                        exhaustArray[i * 3 + 2] = (Math.random() - 0.5) * 30;
                    }
                }
                exhaustParticles.geometry.attributes.position.needsUpdate = true;
                exhaustMat.opacity = 0.8 - progress * 0.3;

                // Update speed lines
                speedLines.position.copy(ship.position);

                // CINEMATIC CAMERA
                if (progress < phases[0].end) {
                    // Power up - dramatic low angle
                    camera.position.set(
                        ship.position.x + 80,
                        ship.position.y - 20,
                        ship.position.z + 100
                    );
                    camera.lookAt(ship.position);
                }
                else if (progress < phases[1].end) {
                    // Liftoff - rising with ship
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    camera.position.set(
                        ship.position.x + 100 - phaseProgress * 20,
                        ship.position.y - 30 + phaseProgress * 20,
                        ship.position.z + 120
                    );
                    camera.lookAt(ship.position);
                }
                else if (progress < phases[2].end) {
                    // Ascent - chase camera
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    camera.position.set(
                        ship.position.x + 50,
                        ship.position.y + 30,
                        ship.position.z + 150
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, 100, 0)));
                    camera.fov = 70 + phaseProgress * 15;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[3].end) {
                    // Escape - behind and below 
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    camera.position.set(
                        ship.position.x,
                        ship.position.y + 50,
                        ship.position.z + 180
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, -200, 0)));
                    camera.fov = 85 - phaseProgress * 10;
                    camera.updateProjectionMatrix();
                }
                else {
                    // Space - settling behind
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    camera.position.lerp(ship.position.clone().add(new THREE.Vector3(0, 15, 65)), 0.05);
                    camera.lookAt(ship.position);
                    camera.fov = 75 - eased * 5;
                    camera.updateProjectionMatrix();
                }

                // Camera shake during thrust
                if (progress > 0.1 && progress < 0.7) {
                    const intensity = 3 * (1 - progress);
                    camera.position.x += (Math.random() - 0.5) * intensity;
                    camera.position.y += (Math.random() - 0.5) * intensity;
                }

                // Engine flames intense during takeoff
                const flameIntensity = 2 + progress * 2;
                engineFlames.forEach((f, i) => {
                    f.scale.setScalar(flameIntensity + Math.sin(elapsed * 0.03 + i) * 0.8);
                });

                renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateTakeoff);
                } else {
                    // Cleanup
                    scene.remove(dustParticles);
                    scene.remove(exhaustParticles);
                    scene.remove(speedLines);

                    dustGeo.dispose();
                    dustMat.dispose();
                    exhaustGeo.dispose();
                    exhaustMat.dispose();
                    speedGeo.dispose();
                    speedMat.dispose();

                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    setTimeout(() => {
                        landingDiv.style.display = 'none';
                        landingText.classList.remove('show');
                        document.getElementById('hud').style.opacity = '1';
                        document.getElementById('crosshair').style.opacity = '1';
                        document.getElementById('prompt').style.opacity = '1';
                        isInCinematic = false;
                        if (callback) callback();
                    }, 500);
                }
            }

            requestAnimationFrame(animateTakeoff);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100000);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            scene.add(new THREE.AmbientLight(0x111122, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 2.5);
            sun.position.set(2000, 2000, 2000);
            scene.add(sun);

            createStars();
            ship = createShip();
            scene.add(ship);
            ship.position.set(0, 0, 1500);

            createHDPlanet("MOLTEN-X", "#ff3300", 400, new THREE.Vector3(3000, 0, -4000), 0xff4400, "Collecter 5 cristaux de lave");
            createHDPlanet("NEPTUNE-PRO", "#0088ff", 450, new THREE.Vector3(-6000, 800, -8000), 0x00ffff, "DÃ©truire 3 antennes alien");
            createHDPlanet("KRYPTON-ELITE", "#44ff44", 350, new THREE.Vector3(0, -2000, -12000), 0x44ff88, "Scanner 4 monolithes anciens");

            window.addEventListener('keydown', e => keys[e.code] = true);
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => {
                if (!gameStarted) return;
                if (!isLocked) document.body.requestPointerLock();
                else if (!isInCinematic) shoot();
            });
            document.addEventListener('pointerlockchange', () => isLocked = document.pointerLockElement === document.body);
            window.addEventListener('keydown', e => { if (e.code === 'KeyE' && !isInCinematic) tryInteract(); });

            // Start intro cinematic
            startIntroCinematic();

            animate();
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 30000; i++) {
                pos.push((Math.random() - 0.5) * 100000, (Math.random() - 0.5) * 100000, (Math.random() - 0.5) * 100000);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, transparent: true, opacity: 0.7 });
            scene.add(new THREE.Points(starGeo, starMat));
        }

        function createShip() {
            const g = new THREE.Group();

            // Texture mÃ©tallique HD
            const metalTex = createMetallicTexture();
            const bodyMat = new THREE.MeshStandardMaterial({
                map: metalTex,
                metalness: 0.95,
                roughness: 0.15,
                envMapIntensity: 1
            });

            // Cockpit en verre avec reflets
            const cockpitGeo = new THREE.SphereGeometry(1.5, 32, 32);
            const cockpit = new THREE.Mesh(cockpitGeo, new THREE.MeshPhysicalMaterial({
                color: 0x00f0ff,
                metalness: 0.2,
                roughness: 0.1,
                transparent: true,
                opacity: 0.4,
                transmission: 0.9
            }));
            cockpit.position.set(0, 0.8, -3);
            g.add(cockpit);

            // Corps principal avec dÃ©tails
            const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 1.5, 10, 16), bodyMat);
            hull.rotation.x = Math.PI / 2;
            g.add(hull);

            // Ailes avec panneaux
            const wingGeo = new THREE.BoxGeometry(14, 0.4, 4);
            const wings = new THREE.Mesh(wingGeo, bodyMat);
            g.add(wings);

            // DÃ©tails nÃ©on
            const neonMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
            for (let i = 0; i < 3; i++) {
                const neon = new THREE.Mesh(new THREE.BoxGeometry(14.2, 0.08, 0.08), neonMat);
                neon.position.z = -1.5 + i * 0.8;
                g.add(neon);
            }

            // Lignes de fuselage
            for (let i = 0; i < 8; i++) {
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 10), bodyMat);
                line.position.x = Math.cos(i * Math.PI / 4) * 1;
                line.position.y = Math.sin(i * Math.PI / 4) * 1;
                line.rotation.x = Math.PI / 2;
                g.add(line);
            }

            // RÃ©acteurs avec glow
            for (let i = 0; i < 2; i++) {
                const engineBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.7, 0.8, 2, 16),
                    bodyMat
                );
                engineBase.rotation.x = Math.PI / 2;
                engineBase.position.set(i === 0 ? -3.5 : 3.5, -0.3, 4);
                g.add(engineBase);

                const flameGeo = new THREE.ConeGeometry(0.6, 4, 16);
                const flame = new THREE.Mesh(flameGeo, new THREE.MeshBasicMaterial({
                    color: 0x00f0ff,
                    transparent: true,
                    opacity: 0.7
                }));
                flame.rotation.x = -Math.PI / 2;
                flame.position.set(i === 0 ? -3.5 : 3.5, -0.3, 6);
                engineFlames.push(flame);
                g.add(flame);

                // Glow externe
                const glowGeo = new THREE.ConeGeometry(1, 6, 16);
                const glow = new THREE.Mesh(glowGeo, new THREE.MeshBasicMaterial({
                    color: 0x00f0ff,
                    transparent: true,
                    opacity: 0.2
                }));
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(i === 0 ? -3.5 : 3.5, -0.3, 7);
                engineFlames.push(glow);
                g.add(glow);
            }

            return g;
        }

        function createHDPlanet(name, color, size, pos, atmosphereColor, missionDesc) {
            const group = new THREE.Group();
            const tex = createPlanetTexture(color);
            const mat = new THREE.MeshStandardMaterial({
                map: tex,
                bumpMap: tex,
                bumpScale: 6,
                roughness: 0.85,
                metalness: 0.1
            });
            const pMesh = new THREE.Mesh(new THREE.SphereGeometry(size, 128, 128), mat);
            group.add(pMesh);

            const clouds = new THREE.Mesh(
                new THREE.SphereGeometry(size * 1.03, 64, 64),
                new THREE.MeshStandardMaterial({
                    map: createPlanetTexture('rgba(255,255,255,0.1)'),
                    transparent: true,
                    opacity: 0.3
                })
            );
            group.add(clouds);

            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(size * 1.2, 64, 64),
                new THREE.MeshBasicMaterial({
                    color: atmosphereColor,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                })
            );
            group.add(glow);

            group.position.copy(pos);
            group.userData = { name, size, atmosphereColor, clouds, color, missionDesc };
            scene.add(group);
            planets.push(group);

            // Ennemis gardiens
            for (let i = 0; i < 3; i++) {
                const enemy = createEnemyShip();
                enemy.position.copy(pos).add(new THREE.Vector3((Math.random() - 0.5) * 3000, (Math.random() - 0.5) * 3000, (Math.random() - 0.5) * 3000));
                enemy.userData = { hp: 5, home: pos.clone(), lastShot: 0, planet: name };
                enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function createEnemyShip() {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.9, roughness: 0.1 });
            const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 1.2, 8, 8), mat);
            hull.rotation.x = Math.PI / 2;
            const wings = new THREE.Mesh(new THREE.BoxGeometry(10, 0.3, 3), mat);
            g.add(hull, wings);
            return g;
        }

        function startMission(planet) {
            const missions = {
                "MOLTEN-X": () => spawnCrystals(5, 0xff6600),
                "NEPTUNE-PRO": () => spawnAntennes(3, 0x0088ff),
                "KRYPTON-ELITE": () => spawnMonolithes(4, 0x44ff44)
            };

            collectedItems = 0;
            missions[planet.userData.name]();

            currentMission = {
                name: planet.userData.name,
                desc: planet.userData.missionDesc,
                total: missionObjects.length,
                collected: 0
            };

            document.getElementById('mission-panel').style.display = 'block';
            document.getElementById('mission-desc').innerText = currentMission.desc;
            updateMissionProgress();

            showNotification(`ðŸŽ¯ MISSION : ${currentMission.desc}`);
        }

        function spawnCrystals(count, color) {
            for (let i = 0; i < count; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(20, 50, 6),
                    new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                crystal.position.set(rx, ry + 25, rz);
                crystal.rotation.z = Math.random() * Math.PI * 2;
                crystal.userData.type = 'collectible';
                planetEnvironment.add(crystal);
                missionObjects.push(crystal);

                // Particules autour
                const particles = createParticleRing(crystal.position, color);
                planetEnvironment.add(particles);
            }
        }

        function spawnAntennes(count, color) {
            for (let i = 0; i < count; i++) {
                const base = new THREE.Group();
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 8, 80, 8),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 })
                );
                const dish = new THREE.Mesh(
                    new THREE.CylinderGeometry(30, 25, 10, 16),
                    new THREE.MeshStandardMaterial({ color: color, metalness: 0.9 })
                );
                dish.position.y = 45;
                base.add(pole, dish);

                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                base.position.set(rx, ry + 40, rz);
                base.userData.type = 'destroyable';
                base.userData.hp = 3;
                planetEnvironment.add(base);
                missionObjects.push(base);
            }
        }

        function spawnMonolithes(count, color) {
            for (let i = 0; i < count; i++) {
                const monolith = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 100, 20),
                    new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        metalness: 0.5,
                        roughness: 0.3
                    })
                );
                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                monolith.position.set(rx, ry + 50, rz);
                monolith.userData.type = 'scannable';
                monolith.userData.scanned = false;
                planetEnvironment.add(monolith);
                missionObjects.push(monolith);

                // Runes lumineuses
                for (let j = 0; j < 5; j++) {
                    const rune = new THREE.Mesh(
                        new THREE.PlaneGeometry(8, 8),
                        new THREE.MeshBasicMaterial({
                            color: color,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    rune.position.set(0, -40 + j * 20, 10.5);
                    monolith.add(rune);
                }
            }
        }

        function createParticleRing(pos, color) {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                positions.push(
                    Math.cos(angle) * 30,
                    Math.sin(i * 0.5) * 10,
                    Math.sin(angle) * 30
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: color,
                size: 5,
                transparent: true,
                opacity: 0.6
            });
            return new THREE.Points(geo, mat);
        }

        function checkMissionObjectInteraction() {
            missionObjects.forEach((obj, index) => {
                const dist = camera.position.distanceTo(obj.position);

                if (obj.userData.type === 'collectible' && dist < 100) {
                    planetEnvironment.remove(obj);
                    missionObjects.splice(index, 1);
                    collectedItems++;
                    score += 100;
                    document.getElementById('score').innerText = "PRIME : " + score;
                    updateMissionProgress();
                    showNotification('âœ… CRISTAL COLLECTÃ‰ !');
                }

                if (obj.userData.type === 'scannable' && !obj.userData.scanned && dist < 150) {
                    document.getElementById('prompt').innerText = "[E] SCANNER LE MONOLITHE";
                }

                if (obj.userData.type === 'destroyable' && dist < 200) {
                    document.getElementById('prompt').innerText = "[CLIC] DÃ‰TRUIRE L'ANTENNE";
                }
            });
        }

        function updateMissionProgress() {
            if (!currentMission) return;
            currentMission.collected = collectedItems;
            const progress = (collectedItems / currentMission.total) * 100;
            document.getElementById('mission-progress-bar').style.width = progress + '%';

            if (collectedItems >= currentMission.total) {
                setTimeout(() => {
                    showNotification('ðŸŽ‰ MISSION ACCOMPLIE ! +500 PRIME');
                    score += 500;
                    document.getElementById('score').innerText = "PRIME : " + score;
                    document.getElementById('mission-panel').style.display = 'none';
                    currentMission = null;
                    missionObjects = [];
                }, 500);
            }
        }

        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.innerText = text;
            notif.style.display = 'block';
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        function startLanding(p) {
            currentPlanetObj = p;

            // Play 3D landing cinematic - the callback fires when cinematic ends
            playLandingCinematic(p, () => {
                // Transition to planet mode after cinematic
                document.getElementById('fade').style.opacity = 1;

                setTimeout(() => {
                    currentMode = 'PLANET';
                    planets.forEach(pl => pl.visible = (pl === p));
                    enemies.forEach(e => e.visible = false);

                    planetEnvironment = new THREE.Group();

                    const groundSize = 12000;
                    const segments = 128;
                    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, segments, segments);

                    const posAttr = groundGeo.attributes.position;
                    for (let i = 0; i < posAttr.count; i++) {
                        const x = posAttr.getX(i);
                        const y = posAttr.getY(i);
                        const z = (Math.sin(x / 500) * Math.cos(y / 500) * 200) + (Math.sin(x / 100) * 30);
                        posAttr.setZ(i, z);
                    }
                    groundGeo.computeVertexNormals();

                    const groundTex = createPlanetTexture(p.userData.color, true);
                    const groundMat = new THREE.MeshStandardMaterial({
                        map: groundTex,
                        bumpMap: groundTex,
                        bumpScale: 10,
                        roughness: 0.9
                    });
                    const ground = new THREE.Mesh(groundGeo, groundMat);
                    ground.rotation.x = -Math.PI / 2;
                    planetEnvironment.add(ground);

                    const rockGeo = new THREE.IcosahedronGeometry(15, 1);
                    for (let i = 0; i < 150; i++) {
                        const rock = new THREE.Mesh(rockGeo, groundMat);
                        const rx = (Math.random() - 0.5) * 8000;
                        const rz = (Math.random() - 0.5) * 8000;
                        const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                        rock.position.set(rx, ry + 5, rz);
                        rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                        rock.scale.setScalar(Math.random() * 3 + 1);
                        planetEnvironment.add(rock);
                    }

                    scene.fog = new THREE.FogExp2(p.userData.atmosphereColor, 0.0004);
                    scene.add(planetEnvironment);

                    ship.scale.set(10, 10, 10);
                    ship.position.set(0, 100, 0);
                    camera.position.set(100, 150, 100);

                    document.getElementById('location').innerText = p.userData.name;
                    document.getElementById('questStatus').innerText = 'EXPLORATION ACTIVE';

                    // Fade back and start mission
                    setTimeout(() => {
                        document.getElementById('fade').style.opacity = 0;
                        startMission(p);
                    }, 500);
                }, 800);
            });
        }

        function exitPlanet() {
            // Clear mission state first
            missionObjects = [];
            currentMission = null;

            // Play takeoff cinematic
            playTakeoffCinematic(() => {
                // After cinematic, transition to space
                document.getElementById('fade').style.opacity = 1;

                setTimeout(() => {
                    currentMode = 'SPACE';
                    scene.remove(planetEnvironment);
                    scene.fog = null;
                    planets.forEach(pl => pl.visible = true);
                    enemies.forEach(e => e.visible = true);
                    ship.scale.set(1, 1, 1);
                    ship.rotation.set(0, 0, 0);
                    ship.position.copy(currentPlanetObj.position).add(new THREE.Vector3(0, 0, 1000));
                    camera.position.copy(ship.position).add(new THREE.Vector3(0, 15, 65));
                    shipRot.yaw = 0;
                    shipRot.pitch = 0;
                    document.getElementById('location').innerText = "ESPACE PROFOND";
                    document.getElementById('questStatus').innerText = 'SCAN SECTEUR';

                    setTimeout(() => {
                        document.getElementById('fade').style.opacity = 0;
                    }, 300);
                }, 500);
            });
        }

        function onMouseMove(e) {
            if (!isLocked) return;
            const s = 0.002;
            if (currentMode === 'SPACE') {
                shipRot.yaw -= e.movementX * s;
                shipRot.pitch -= e.movementY * s;
            } else {
                playerRot.yaw -= e.movementX * s;
                playerRot.pitch = Math.max(-1.5, Math.min(1.5, playerRot.pitch - e.movementY * s));
            }
        }

        function shoot() {
            const laser = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 20), new THREE.MeshBasicMaterial({ color: 0x00f0ff }));
            const dir = new THREE.Vector3(0, 0, -1);
            if (currentMode === 'SPACE') {
                laser.position.copy(ship.position);
                laser.quaternion.copy(ship.quaternion);
                dir.applyQuaternion(ship.quaternion);
            } else {
                laser.position.copy(camera.position);
                laser.quaternion.copy(camera.quaternion);
                dir.applyQuaternion(camera.quaternion);
            }
            scene.add(laser);
            let frames = 0;
            function move() {
                laser.position.addScaledVector(dir, 50);

                enemies.forEach((en, i) => {
                    if (laser.position.distanceTo(en.position) < 100) {
                        en.userData.hp--;
                        if (en.userData.hp <= 0) {
                            score += 50;
                            document.getElementById('score').innerText = "PRIME : " + score;
                            scene.remove(en);
                            enemies.splice(i, 1);
                        }
                        scene.remove(laser);
                        return;
                    }
                });

                missionObjects.forEach((obj, i) => {
                    if (obj.userData.type === 'destroyable' && laser.position.distanceTo(obj.position) < 100) {
                        obj.userData.hp--;
                        if (obj.userData.hp <= 0) {
                            planetEnvironment.remove(obj);
                            missionObjects.splice(i, 1);
                            collectedItems++;
                            score += 150;
                            document.getElementById('score').innerText = "PRIME : " + score;
                            updateMissionProgress();
                            showNotification('ðŸ’¥ ANTENNE DÃ‰TRUITE !');
                        }
                        scene.remove(laser);
                        return;
                    }
                });

                if (frames++ < 40) requestAnimationFrame(move);
                else scene.remove(laser);
            } move();
        }

        function enemyShoot(enemy) {
            const laser = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 20), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            laser.position.copy(enemy.position);
            laser.lookAt(ship.position);
            scene.add(laser);

            const dir = new THREE.Vector3().subVectors(ship.position, enemy.position).normalize();
            let frames = 0;
            function move() {
                laser.position.addScaledVector(dir, 40);

                if (currentMode === 'SPACE' && laser.position.distanceTo(ship.position) < 50) {
                    takeDamage(5);
                    scene.remove(laser);
                    return;
                }

                if (frames++ < 50) requestAnimationFrame(move);
                else scene.remove(laser);
            } move();
        }

        function takeDamage(val) {
            health -= val;
            document.getElementById('health-bar').style.width = health + "%";
            document.getElementById('damage-overlay').style.backgroundColor = "rgba(255,0,0,0.3)";
            setTimeout(() => { document.getElementById('damage-overlay').style.backgroundColor = "transparent"; }, 150);
            if (health <= 0) {
                alert("GAME OVER - VAISSEAU DÃ‰TRUIT");
                location.reload();
            }
        }

        function tryInteract() {
            if (currentMode === 'SPACE') {
                planets.forEach(p => {
                    if (ship.position.distanceTo(p.position) < p.userData.size + 800) startLanding(p);
                });
            } else {
                if (camera.position.distanceTo(ship.position) < 150) {
                    exitPlanet();
                } else {
                    missionObjects.forEach(obj => {
                        if (obj.userData.type === 'scannable' && !obj.userData.scanned && camera.position.distanceTo(obj.position) < 150) {
                            obj.userData.scanned = true;
                            collectedItems++;
                            score += 120;
                            document.getElementById('score').innerText = "PRIME : " + score;
                            updateMissionProgress();
                            showNotification('ðŸ” MONOLITHE SCANNÃ‰ !');

                            obj.traverse(child => {
                                if (child.isMesh && child.material.emissive) {
                                    child.material.emissiveIntensity = 1;
                                }
                            });
                        }
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Skip game logic during cinematics
            if (isInCinematic || !gameStarted) {
                renderer.render(scene, camera);
                return;
            }

            if (isLocked) {
                if (currentMode === 'SPACE') {
                    ship.quaternion.setFromEuler(new THREE.Euler(shipRot.pitch, shipRot.yaw, 0, 'YXZ'));
                    const speed = (keys['ShiftLeft'] ? 1800 : 700) * delta;
                    if (keys['KeyW'] || keys['KeyZ']) ship.translateZ(-speed);
                    if (keys['KeyS']) ship.translateZ(speed * 0.5);

                    engineFlames.forEach((f, i) => {
                        const scale = keys['KeyW'] || keys['KeyZ'] ? 1.8 : 0.5;
                        f.scale.setScalar(scale + Math.sin(time * 10 + i) * 0.2);
                    });

                    camera.position.lerp(ship.position.clone().add(new THREE.Vector3(0, 15, 65).applyQuaternion(ship.quaternion)), 0.1);
                    camera.lookAt(ship.position);

                    planets.forEach(p => {
                        p.rotation.y += 0.001;
                        p.userData.clouds.rotation.y += 0.0015;
                        if (ship.position.distanceTo(p.position) < p.userData.size + 800) {
                            document.getElementById('prompt').innerText = "[E] ATTERRIR SUR " + p.userData.name;
                        } else if (document.getElementById('prompt').innerText.includes(p.userData.name)) {
                            document.getElementById('prompt').innerText = "";
                        }
                    });

                    enemies.forEach(en => {
                        const distToPlayer = en.position.distanceTo(ship.position);
                        const distToHome = en.position.distanceTo(en.userData.home);

                        if (distToPlayer < 4000 && distToHome < 5000) {
                            en.lookAt(ship.position);
                            en.translateZ(-15);
                            if (time - en.userData.lastShot > 2.5) {
                                enemyShoot(en);
                                en.userData.lastShot = time;
                            }
                        } else {
                            en.position.x = en.userData.home.x + Math.sin(time * 0.3) * 1500;
                            en.position.z = en.userData.home.z + Math.cos(time * 0.3) * 1500;
                            en.lookAt(en.userData.home);
                        }
                    });

                } else {
                    camera.rotation.set(playerRot.pitch, playerRot.yaw, 0, 'YXZ');
                    const moveSpd = 350 * delta;
                    if (keys['KeyW'] || keys['KeyZ']) camera.translateZ(-moveSpd);
                    if (keys['KeyS']) camera.translateZ(moveSpd);
                    if (keys['KeyA'] || keys['KeyQ']) camera.translateX(-moveSpd);
                    if (keys['KeyD']) camera.translateX(moveSpd);

                    const tx = camera.position.x;
                    const tz = camera.position.z;
                    const ty = (Math.sin(tx / 500) * Math.cos(tz / 500) * 200) + (Math.sin(tx / 100) * 30);
                    camera.position.y = ty + 40;

                    document.getElementById('prompt').innerText = "";
                    if (camera.position.distanceTo(ship.position) < 200) {
                        document.getElementById('prompt').innerText = "[E] RETOUR AU VAISSEAU";
                    }

                    checkMissionObjectInteraction();
                }
            }
            renderer.render(scene, camera);
        }

        init();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>
