<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OdyssÃ©e Spatiale Pro - Ahmed Edition Ultime</title>
    <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00f0ff;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.7);
            z-index: 10;
        }

        .hud-panel {
            background: rgba(0, 10, 20, 0.9);
            backdrop-filter: blur(15px);
            padding: 15px;
            border-left: 4px solid #00f0ff;
            border-radius: 0 10px 10px 0;
            border: 1px solid rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
        }

        #health-container {
            width: 220px;
            height: 14px;
            background: rgba(255, 0, 0, 0.1);
            margin-top: 10px;
            border: 1px solid rgba(255, 50, 50, 0.5);
        }

        #health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4d4d);
            box-shadow: 0 0 15px #ff0000;
            transition: width 0.2s ease-out;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 44px;
            height: 44px;
            border: 2px solid rgba(0, 240, 255, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #00f0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #prompt {
            position: absolute;
            top: 80%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-weight: bold;
            font-size: 1.4rem;
            text-shadow: 0 0 15px #00f0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(0, 240, 255, 0.5);
        }

        #fade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            transition: opacity 0.8s;
        }

        #damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: background 0.1s;
            z-index: 99;
        }

        #mission-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 170, 0, 0.15);
            backdrop-filter: blur(15px);
            padding: 15px;
            border-right: 4px solid #ffaa00;
            border-radius: 10px 0 0 10px;
            border: 1px solid rgba(255, 170, 0, 0.3);
            color: #ffaa00;
            max-width: 300px;
            display: none;
            z-index: 10;
        }

        .mission-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 170, 0, 0.7);
        }

        .mission-desc {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .mission-progress {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .mission-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ffdd00);
            box-shadow: 0 0 10px #ffaa00;
            transition: width 0.3s;
        }

        /* RADAR UI */
        #radar-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 180px;
            border: 2px solid rgba(0, 240, 255, 0.4);
            border-radius: 50%;
            background: rgba(0, 10, 20, 0.7);
            backdrop-filter: blur(10px);
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
            overflow: hidden;
            pointer-events: none;
        }

        #radar-canvas {
            width: 100%;
            height: 100%;
        }

        #objective-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-bottom: 3px solid #00f0ff;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            z-index: 100;
            min-width: 300px;
            border-radius: 0 0 10px 10px;
        }

        #objective-title {
            color: #ffaa00;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        #objective-desc {
            font-size: 1.1rem;
            font-weight: bold;
        }

        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 240, 255, 0.2);
            backdrop-filter: blur(15px);
            padding: 30px 50px;
            border-radius: 20px;
            border: 2px solid #00f0ff;
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 300;
            box-shadow: 0 0 40px rgba(0, 240, 255, 0.5);
        }

        /* Cinematic Intro Styles */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.5s ease;
        }

        #intro-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .intro-title {
            font-size: 4rem;
            font-weight: bold;
            color: #00f0ff;
            text-shadow: 0 0 60px #00f0ff, 0 0 100px #00f0ff;
            letter-spacing: 15px;
            animation: titleGlow 2s ease-in-out infinite alternate;
            opacity: 0;
            animation: fadeInUp 2s ease forwards 0.5s, titleGlow 2s ease-in-out infinite alternate 2.5s;
        }

        .intro-subtitle {
            font-size: 1.5rem;
            color: #ffaa00;
            letter-spacing: 8px;
            margin-top: 20px;
            opacity: 0;
            animation: fadeInUp 2s ease forwards 1.5s;
        }

        .intro-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s ease-in-out infinite;
        }

        .intro-ship {
            position: absolute;
            width: 80px;
            height: 30px;
            bottom: -100px;
            opacity: 0;
            animation: shipFlyIn 3s ease-out forwards 2.5s;
        }

        .intro-ship::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00f0ff 0%, transparent 100%);
            clip-path: polygon(0 50%, 100% 0, 100% 100%);
            filter: drop-shadow(0 0 20px #00f0ff);
        }

        .intro-ship::after {
            content: '';
            position: absolute;
            left: -40px;
            top: 5px;
            width: 40px;
            height: 20px;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            border-radius: 50%;
            filter: blur(8px);
            animation: enginePulse 0.3s ease-in-out infinite alternate;
        }

        .press-start {
            position: absolute;
            bottom: 15%;
            font-size: 1.2rem;
            color: #fff;
            letter-spacing: 5px;
            opacity: 0;
            animation: fadeInUp 1s ease forwards 4s, blink 1s ease-in-out infinite 5s;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 60px #00f0ff, 0 0 100px #00f0ff;
            }

            to {
                text-shadow: 0 0 80px #00f0ff, 0 0 150px #00f0ff, 0 0 200px #0088ff;
            }
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        @keyframes shipFlyIn {
            0% {
                bottom: -100px;
                left: 10%;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                bottom: 50%;
                left: 60%;
                opacity: 0;
            }
        }

        @keyframes enginePulse {
            from {
                width: 40px;
                opacity: 0.8;
            }

            to {
                width: 60px;
                opacity: 1;
            }
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* Landing Cinematic */
        #landing-cinematic {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 500;
            pointer-events: none;
            display: none;
        }

        .landing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.8) 100%);
        }

        .friction-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .friction-line {
            position: absolute;
            width: 3px;
            height: 100px;
            background: linear-gradient(to bottom, transparent, #ff6600, #ffaa00, transparent);
            animation: frictionFall 0.5s linear infinite;
            opacity: 0;
        }

        @keyframes frictionFall {
            from {
                transform: translateY(-100px);
                opacity: 0.8;
            }

            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        .landing-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffaa00;
            text-shadow: 0 0 30px #ff6600;
            letter-spacing: 10px;
            opacity: 0;
        }

        .landing-text.show {
            animation: landingTextPulse 2s ease-in-out;
        }

        @keyframes landingTextPulse {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .heat-glow {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: linear-gradient(to top, rgba(255, 100, 0, 0.4), transparent);
            opacity: 0;
        }
    </style>
</head>

<body>

    <div id="damage-overlay"></div>
    <div id="hud">
        <div class="hud-panel">
            <div id="gameMode" style="font-weight: bold; letter-spacing: 3px; color: #00f0ff;">COMMANDANT AHMED</div>
            <div id="location" style="opacity: 0.9; font-size: 0.85rem; margin-top: 4px;">SYNCHRONISATION...</div>
            <div id="questStatus" style="color: #ffaa00; font-weight: bold; margin-top: 8px; font-size: 0.8rem;">SCAN
                SECTEUR</div>
            <div id="health-container">
                <div id="health-bar"></div>
            </div>
            <div id="score" style="margin-top: 10px; color: #ffaa00; font-size: 14px;">PRIME : 0</div>
        </div>
    </div>

    <div id="objective-panel">
        <div id="objective-title">DIRECTIONS DE MISSION</div>
        <div id="objective-desc" id="objective-desc">SYNCHRONISATION...</div>
    </div>

    <!-- RADAR -->
    <div id="radar-container" id="radar-ui">
        <canvas id="radar-canvas" width="180" height="180"></canvas>
    </div>

    <div id="notification"></div>
    <div id="prompt"></div>
    <div id="crosshair"></div>
    <div id="fade"></div>

    <!-- Intro Cinematic -->
    <div id="intro-screen">
        <div class="intro-stars" id="intro-stars"></div>
        <div class="intro-title">ODYSSÃ‰E SPATIALE</div>
        <div class="intro-subtitle">AHMED EDITION ULTIME</div>
        <div class="intro-ship"></div>
        <div class="press-start">CLIQUEZ POUR COMMENCER</div>
    </div>

    <!-- Landing Cinematic -->
    <div id="landing-cinematic">
        <div class="landing-overlay"></div>
        <div class="friction-lines" id="friction-lines"></div>
        <div class="heat-glow" id="heat-glow"></div>
        <div class="landing-text" id="landing-text">ENTRÃ‰E ATMOSPHÃ‰RIQUE</div>
    </div>

    <!-- SHOP UI -->
    <div id="shop-ui"
        style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: rgba(0, 20, 40, 0.9); border: 2px solid #00f0ff; padding: 20px; color: #fff; font-family: 'Orbitron', sans-serif; z-index: 1000; box-shadow: 0 0 50px rgba(0, 240, 255, 0.3);">
        <h2 style="text-align: center; color: #00f0ff; text-shadow: 0 0 10px #00f0ff;">BOUTIQUE GALACTIQUE</h2>
        <div
            style="display: flex; justify-content: space-between; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px;">
            <span>CRÃ‰DITS: <span id="shop-credits" style="color: #ffaa00;">0</span></span>
            <span style="font-size: 0.8em; color: #888;">Appuyez sur 'B' pour fermer</span>
        </div>
        <div id="shop-items" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <!-- Items injected by JS -->
        </div>
    </div>

    <script>
        let scene, camera, renderer, composer, clock;
        let isLocked = false, currentMode = 'SPACE';
        let ship, stars, currentPlanetObj, planetEnvironment, engineFlames = [];
        let planets = [];
        let enemies = []; // Space and Ground enemies
        let spaceEnemies = [];
        let health = 100, credits = 0; // Renamed score to credits
        let shipHealth = 1000; // New Ship HP
        let maxShipHealth = 1000;
        let upgrades = {
            laserLevel: 1, // 1 = Single, 2 = Twin, 3 = Quad
            damage: 1,
            speed: 1,
            armor: 1
        };
        let keys = {};
        const shipRot = { yaw: 0, pitch: 0 };
        const playerRot = { yaw: 0, pitch: 0 };

        // SystÃ¨me de missions
        let currentMission = null;
        let missionObjects = [];
        let collectedItems = 0;
        let planetMissionStage = 0; // NEW: tracking multi-step planet missions

        // Cinematic states
        let gameStarted = false;
        let isInCinematic = false;
        let shopOpen = false;

        // --- GAMEPLAY V3 CAMPAIGN ---
        let questStage = 0;
        let warpGate = null;
        let specialItems = {
            cipherFound: false,
            powerCores: 0,
            gateRepaired: false
        };

        const QUEST_STAGES = [
            { title: "INITIATION", desc: "Accumulez 1000 crÃ©dits pour prÃ©parer le voyage.", goal: 1000 },
            { title: "ARMEMENT", desc: "Achetez l'armure 'Titan Plating' dans la Boutique (B).", goal: 1 },
            { title: "LE CHIFFRE", desc: "Trouvez le Chiffre Ancien sur NEPTUNE-PRO.", goal: 1 },
            { title: "Ã‰NERGIE NOIRE", desc: "Collectez 5 Noyaux d'Ã‰nergie sur MOLTEN-X.", goal: 5 },
            { title: "ASCENSION", desc: "Atteignez la Porte Warp et activez-la (5000 CR).", goal: 5000 }
        ];

        // --- TEXTURES ULTRA HD PROCÃ‰DURALES ---
        // --- TEXTURES ULTRA HD PROCÃ‰DURALES AMÃ‰LIORÃ‰ES ---

        // Simple Value Noise implementation for procedural generation
        const Noise = {
            p: new Uint8Array(512),
            permutation: [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
            init: function () {
                for (let i = 0; i < 256; i++) this.p[256 + i] = this.p[i] = this.permutation[i];
            },
            fade: function (t) { return t * t * t * (t * (t * 6 - 15) + 10); },
            lerp: function (t, a, b) { return a + t * (b - a); },
            grad: function (hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            },
            scale: function (n) { return (1 + n) / 2; },
            perlin3: function (x, y, z) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = this.fade(x), v = this.fade(y), w = this.fade(z);
                const A = this.p[X] + Y, AA = this.p[A] + Z, AB = this.p[A + 1] + Z,
                    B = this.p[X + 1] + Y, BA = this.p[B] + Z, BB = this.p[B + 1] + Z;
                return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, z),
                    this.grad(this.p[BA], x - 1, y, z)),
                    this.lerp(u, this.grad(this.p[AB], x, y - 1, z),
                        this.grad(this.p[BB], x - 1, y - 1, z))),
                    this.lerp(v, this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1),
                        this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1),
                            this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))));
            }
        };
        Noise.init();

        function createMetallicTexture() {
            // Generates maps for realistic metal
            const width = 2048, height = 2048; // ULTRA HD
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // 1. Diffuse/Albedo Map
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    // Brushed metal noise
                    const noiseVal = Noise.perlin3(x * 0.05, y * 0.005, 0);
                    const val = 100 + noiseVal * 100;

                    data[idx] = val; // R
                    data[idx + 1] = val; // G
                    data[idx + 2] = val + 10; // B (slightly bluish tint)
                    data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);

            // Add panels/plates details
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 20; i++) {
                ctx.moveTo(0, Math.random() * height);
                ctx.lineTo(width, Math.random() * height);
                ctx.moveTo(Math.random() * width, 0);
                ctx.lineTo(Math.random() * width, height);
            }
            ctx.stroke();

            // Scratches
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 1;
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50);
                ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createPlanetTexture(baseColor, isGround = false) {
            const size = 2048; // ULTRA HD UNIFIED
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const imgData = ctx.createImageData(size, size);
            const data = imgData.data;

            const rBase = parseInt(baseColor.substr(1, 2), 16);
            const gBase = parseInt(baseColor.substr(3, 2), 16);
            const bBase = parseInt(baseColor.substr(5, 2), 16);

            const scale = isGround ? 0.01 : 0.02;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = (y * size + x) * 4;

                    // Layered noise for terrain
                    let n = Noise.perlin3(x * scale, y * scale, 0);
                    n += 0.5 * Noise.perlin3(x * scale * 2, y * scale * 2, 10);
                    n += 0.25 * Noise.perlin3(x * scale * 4, y * scale * 4, 20);

                    // Normalize -1..1 to 0..1 approx
                    const val = Math.max(0, Math.min(1, (n + 1) / 2));

                    data[idx] = rBase * val;
                    data[idx + 1] = gBase * val;
                    data[idx + 2] = bBase * val;
                    data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            if (isGround) tex.repeat.set(4, 4);
            tex.anisotropy = 16;
            return tex;
        }

        function adjustColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Generate stars for intro screen
        function generateIntroStars() {
            const container = document.getElementById('intro-stars');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                const size = Math.random() * 4 + 1;
                star.style.width = star.style.height = size + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                // Some stars are brighter
                if (Math.random() > 0.9) {
                    star.style.boxShadow = '0 0 ' + (size * 3) + 'px #00f0ff';
                }
                container.appendChild(star);
            }
        }

        // Start intro cinematic
        function startIntroCinematic() {
            generateIntroStars();

            // Hide game UI during intro
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';

            // Click to start
            document.getElementById('intro-screen').addEventListener('click', () => {
                if (!gameStarted) {
                    gameStarted = true;
                    document.getElementById('intro-screen').classList.add('hidden');

                    // Play epic fly-through cinematic
                    playEpicIntroCinematic();
                }
            });
        }

        // EPIC INTRO CINEMATIC - Multiple phases with dramatic camera work
        function playEpicIntroCinematic() {
            isInCinematic = true;

            // Create warp speed particles
            const warpParticleCount = 500;
            const warpGeo = new THREE.BufferGeometry();
            const warpPositions = new Float32Array(warpParticleCount * 3);
            const warpVelocities = [];

            for (let i = 0; i < warpParticleCount; i++) {
                warpPositions[i * 3] = (Math.random() - 0.5) * 2000;
                warpPositions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                warpPositions[i * 3 + 2] = (Math.random() - 0.5) * 5000;
                warpVelocities.push(Math.random() * 50 + 20);
            }
            warpGeo.setAttribute('position', new THREE.BufferAttribute(warpPositions, 3));

            const warpMat = new THREE.PointsMaterial({
                color: 0x00f0ff,
                size: 3,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending
            });
            const warpParticles = new THREE.Points(warpGeo, warpMat);
            scene.add(warpParticles);

            // Create lens flare effect mesh
            const flareGeo = new THREE.PlaneGeometry(500, 500);
            const flareMat = new THREE.MeshBasicMaterial({
                color: 0x00f0ff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const lensFlare = new THREE.Mesh(flareGeo, flareMat);
            scene.add(lensFlare);

            // Position ship far away
            ship.position.set(-5000, 1000, -8000);
            ship.rotation.set(0, Math.PI * 0.3, 0);

            // Cinematic timing
            let cinematicStart = 0;
            const totalDuration = 12000; // 12 seconds epic intro

            // Camera keyframes for different phases
            const phases = [
                { name: 'SPACE_PAN', start: 0, end: 0.15 },        // Pan across space
                { name: 'SHIP_REVEAL', start: 0.15, end: 0.35 },   // Reveal ship from distance
                { name: 'FLYBY', start: 0.35, end: 0.55 },         // Dramatic flyby
                { name: 'WARP_SPEED', start: 0.55, end: 0.75 },    // Warp speed effect
                { name: 'ARRIVAL', start: 0.75, end: 1.0 }         // Arrive at starting position
            ];

            function animateIntro(timestamp) {
                if (cinematicStart === 0) cinematicStart = timestamp;
                const elapsed = timestamp - cinematicStart;
                const progress = Math.min(elapsed / totalDuration, 1);

                // Easing functions
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeOut = t => 1 - Math.pow(1 - t, 3);

                // Update warp particles
                const warpPositionsArray = warpParticles.geometry.attributes.position.array;
                for (let i = 0; i < warpParticleCount; i++) {
                    warpPositionsArray[i * 3 + 2] += warpVelocities[i];
                    if (warpPositionsArray[i * 3 + 2] > 3000) {
                        warpPositionsArray[i * 3 + 2] = -3000;
                        warpPositionsArray[i * 3] = (Math.random() - 0.5) * 2000;
                        warpPositionsArray[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                    }
                }
                warpParticles.geometry.attributes.position.needsUpdate = true;

                // PHASE 1: Space Pan - Camera slowly pans across the starfield
                if (progress < phases[0].end) {
                    const phaseProgress = progress / phases[0].end;
                    camera.position.set(
                        -8000 + phaseProgress * 2000,
                        2000 - phaseProgress * 500,
                        5000
                    );
                    camera.lookAt(new THREE.Vector3(0, 0, -5000));

                    // Ship is hidden initially
                    ship.visible = false;
                }
                // PHASE 2: Ship Reveal - Ship comes into view
                else if (progress < phases[1].end) {
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const eased = easeOut(phaseProgress);

                    ship.visible = true;
                    ship.position.set(
                        -5000 + eased * 3000,
                        1000 - eased * 500,
                        -8000 + eased * 4000
                    );

                    camera.position.set(
                        ship.position.x + 4000 - eased * 2000, // x5
                        ship.position.y + 1000, // x5
                        ship.position.z + 5000 // x5
                    );
                    camera.lookAt(ship.position);

                    // Animate engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1.2 + Math.sin(elapsed * 0.015 + i) * 0.4);
                    });
                }
                // PHASE 3: Dramatic Flyby - Camera does a dramatic orbit around ship
                else if (progress < phases[2].end) {
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const eased = easeInOut(phaseProgress);

                    // Ship continues moving
                    ship.position.set(
                        -10000 + eased * 7500, // x5 (-2000 -> -10000)
                        2500 + Math.sin(eased * Math.PI) * 1000, // x5
                        -20000 + eased * 12500 // x5
                    );
                    ship.rotation.y = Math.PI * 0.3 - eased * 0.4;

                    // Camera orbits around ship
                    const orbitAngle = phaseProgress * Math.PI * 0.8;
                    camera.position.set(
                        ship.position.x + Math.cos(orbitAngle) * 1500, // x5
                        ship.position.y + 250 + Math.sin(orbitAngle * 2) * 500, // x5
                        ship.position.z + Math.sin(orbitAngle) * 2000 + 1000 // x5
                    );
                    camera.lookAt(ship.position);

                    // Engine flames intensify
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1.5 + Math.sin(elapsed * 0.02 + i) * 0.5);
                    });
                }
                // PHASE 4: Warp Speed - Dramatic speed effect
                else if (progress < phases[3].end) {
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const eased = easeInOut(phaseProgress);

                    // Warp particles become visible and stretch
                    warpMat.opacity = Math.sin(phaseProgress * Math.PI) * 0.8;
                    warpParticles.position.copy(ship.position);

                    // Ship accelerates dramatically
                    ship.position.set(
                        -2500 + eased * 2000, // x5
                        2500 + eased * -2000, // x5
                        -7500 + eased * 14000 // x5
                    );
                    ship.rotation.y = Math.PI * -0.1;

                    // Camera behind ship for warp effect
                    camera.position.set(
                        ship.position.x,
                        ship.position.y + 150, // x5
                        ship.position.z + 750 // x5
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, 0, -2500))); // x5

                    // Lens flare effect
                    lensFlare.position.copy(camera.position).add(new THREE.Vector3(0, 0, -1000)); // x5
                    lensFlare.lookAt(camera.position);
                    flareMat.opacity = Math.sin(phaseProgress * Math.PI) * 0.3;

                    // Maximum engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(2.5 + Math.sin(elapsed * 0.03 + i) * 0.8);
                    });

                    // Camera FOV change for speed effect
                    camera.fov = 70 + Math.sin(phaseProgress * Math.PI) * 20;
                    camera.updateProjectionMatrix();
                }
                // PHASE 5: Arrival - Slow down and settle at starting position
                else {
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);

                    // Fade out warp particles
                    warpMat.opacity = (1 - eased) * 0.5;
                    flareMat.opacity = 0;

                    // Ship slows down
                    ship.position.set(
                        -500 + eased * 500, // x5
                        500 + eased * -500, // x5
                        6500 + eased * 1000 // x5
                    );
                    ship.rotation.set(0, 0, 0);

                    // Camera settles behind ship
                    const targetCamPos = ship.position.clone().add(new THREE.Vector3(0, 75, 325)); // x5
                    camera.position.lerp(targetCamPos, 0.08);
                    camera.lookAt(ship.position);

                    // Reset FOV
                    camera.fov = 70 + (1 - eased) * 10;
                    camera.updateProjectionMatrix();

                    // Normal engine flames
                    engineFlames.forEach((f, i) => {
                        f.scale.setScalar(1 + (1 - eased) * 1.5 + Math.sin(elapsed * 0.01 + i) * 0.3);
                    });
                }

                if (composer) composer.render();
                else renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateIntro);
                } else {
                    // Cleanup
                    scene.remove(warpParticles);
                    scene.remove(lensFlare);
                    warpGeo.dispose();
                    warpMat.dispose();
                    flareGeo.dispose();
                    flareMat.dispose();

                    // Reset camera FOV
                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    isInCinematic = false;
                    ship.visible = true;
                    document.getElementById('hud').style.opacity = '1';
                    document.getElementById('crosshair').style.opacity = '1';
                    document.getElementById('hud').style.transition = 'opacity 1s';
                    document.getElementById('crosshair').style.transition = 'opacity 1s';
                }
            }

            requestAnimationFrame(animateIntro);
        }

        // Landing cinematic - ULTRA EPIC 3D CINEMATIC
        let landingParticles = null;
        let reentryGlow = null;
        let atmosphericClouds = null;
        let fireTrail = null;

        function playLandingCinematic(planet, callback) {
            isInCinematic = true;

            const landingDiv = document.getElementById('landing-cinematic');
            const landingText = document.getElementById('landing-text');
            const heatGlow = document.getElementById('heat-glow');

            landingDiv.style.display = 'block';

            // Hide UI during cinematic
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';
            document.getElementById('prompt').style.opacity = '0';

            // Position ship high above the planet for cinematic entry
            const planetPos = planet.position.clone();
            const startHeight = planet.userData.size + 10000; // Updated height
            const approachAngle = Math.random() * Math.PI * 2;

            ship.scale.set(1, 1, 1);
            ship.position.set(
                planetPos.x + Math.cos(approachAngle) * 2500, // x3 radius
                planetPos.y + startHeight,
                planetPos.z + Math.sin(approachAngle) * 2500 // x3 radius
            );
            // Set proper initial rotation - nose pointing down toward planet
            ship.rotation.order = 'YXZ';
            ship.rotation.y = approachAngle + Math.PI / 2; // Face tangent direction
            ship.rotation.x = 0.8; // Nose down for reentry
            ship.rotation.z = 0;

            // Create massive reentry particle effects
            const particleCount = 1000; // Increased count
            const particleGeo = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                particlePositions[i * 3] = (Math.random() - 0.5) * 300; // x4 width
                particlePositions[i * 3 + 1] = Math.random() * 600; // x3 height
                particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 300; // x4 width
                // Orange to yellow gradient
                particleColors[i * 3] = 1.0;
                particleColors[i * 3 + 1] = 0.3 + Math.random() * 0.5;
                particleColors[i * 3 + 2] = 0;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleMat = new THREE.PointsMaterial({
                size: 8, // Larger particles
                transparent: true,
                opacity: 0.9,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });

            landingParticles = new THREE.Points(particleGeo, particleMat);
            scene.add(landingParticles);

            // Create multiple reentry glow layers
            const glowGeo = new THREE.SphereGeometry(120, 32, 32); // x3 radius
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.5,
                side: THREE.BackSide
            });
            reentryGlow = new THREE.Mesh(glowGeo, glowMat);
            scene.add(reentryGlow);

            // Outer corona glow
            const coronaGeo = new THREE.SphereGeometry(180, 32, 32); // x3 radius
            const coronaMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const coronaGlow = new THREE.Mesh(coronaGeo, coronaMat);
            scene.add(coronaGlow);

            // Create fire trail behind ship
            const trailCount = 200; // More trail
            const trailGeo = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(trailCount * 3);
            for (let i = 0; i < trailCount; i++) {
                trailPositions[i * 3] = (Math.random() - 0.5) * 20; // Spread x
                trailPositions[i * 3 + 1] = i * 6; // Longer trail
                trailPositions[i * 3 + 2] = (Math.random() - 0.5) * 20; // Spread z
            }
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMat = new THREE.PointsMaterial({
                color: 0xff2200,
                size: 15, // Huge fire
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            fireTrail = new THREE.Points(trailGeo, trailMat);
            scene.add(fireTrail);

            // Create heat shield effect (glowing disc in front of ship)
            const shieldGeo = new THREE.CircleGeometry(70, 32); // x3 radius (70 covers 50 width well)
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const heatShield = new THREE.Mesh(shieldGeo, shieldMat);
            scene.add(heatShield);

            // Create shock wave rings
            const shockwaveGeo = new THREE.RingGeometry(60, 80, 32); // Larger rings
            const shockwaveMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const shockwave = new THREE.Mesh(shockwaveGeo, shockwaveMat);
            scene.add(shockwave);

            // Cinematic timing - Extended to 10 seconds
            let cinematicStartTime = 0;
            const totalDuration = 10000;

            // 5 Camera phases for epic landing
            const phases = [
                { name: 'SPACE_VIEW', start: 0, end: 0.15 },        // View from space with planet below
                { name: 'ATMOSPHERE_ENTRY', start: 0.15, end: 0.35 }, // Dramatic atmospheric entry
                { name: 'FIREBALL', start: 0.35, end: 0.55 },        // Ship is a fireball
                { name: 'CLOUD_BREAK', start: 0.55, end: 0.75 },     // Breaking through clouds
                { name: 'FINAL_DESCENT', start: 0.75, end: 1.0 }     // Landing sequence
            ];

            // Show text phases
            landingText.textContent = 'ðŸ›¸ APPROCHE ORBITALE';
            landingText.classList.add('show');

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸ”¥ ENTRÃ‰E ATMOSPHÃ‰RIQUE';
                landingText.classList.add('show');
                heatGlow.style.transition = 'opacity 0.3s';
                heatGlow.style.opacity = '0.7';
            }, 1500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸŒ ' + planet.userData.name;
                landingText.classList.add('show');
            }, 3500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'â˜ï¸ TRAVERSÃ‰E NUAGEUSE';
                landingText.classList.add('show');
                heatGlow.style.opacity = '0.3';
            }, 5500);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'âœ… ATTERRISSAGE';
                landingText.classList.add('show');
                heatGlow.style.opacity = '0';
            }, 7500);

            function animateLanding(timestamp) {
                if (cinematicStartTime === 0) cinematicStartTime = timestamp;
                const elapsed = timestamp - cinematicStartTime;
                const progress = Math.min(elapsed / totalDuration, 1);

                // Easing functions
                const easeOut = t => 1 - Math.pow(1 - t, 3);
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                const easeIn = t => t * t * t;

                // Ship descends with dramatic curve
                const descentProgress = easeInOut(progress);
                const currentHeight = startHeight - (descentProgress * (startHeight - 80));
                const spiralAngle = approachAngle + progress * Math.PI * 0.5;
                const spiralRadius = 800 * (1 - descentProgress * 0.9);

                // Calculate ship position - descending in a spiral
                const shipX = planetPos.x + Math.cos(spiralAngle) * spiralRadius;
                const shipY = planetPos.y + currentHeight;
                const shipZ = planetPos.z + Math.sin(spiralAngle) * spiralRadius;
                ship.position.set(shipX, shipY, shipZ);

                // Calculate proper ship orientation - ALWAYS pointing down toward planet center
                // Use lookAt to point ship toward where it's going (center of planet)
                const targetPoint = new THREE.Vector3(planetPos.x, planetPos.y, planetPos.z);

                // Calculate direction to planet center
                const dirToPlanet = new THREE.Vector3().subVectors(targetPoint, ship.position).normalize();

                // Ship pitch: nose down during entry, gradually leveling out
                const pitchAngle = 0.8 * (1 - easeOut(progress)); // Start at 0.8 rad, end at 0

                // Ship yaw: facing the direction of travel (tangent to spiral)
                const tangentAngle = spiralAngle + Math.PI / 2; // Perpendicular to radius

                // Apply rotations in correct order (YXZ to avoid gimbal issues)
                ship.rotation.order = 'YXZ';
                ship.rotation.y = tangentAngle;
                ship.rotation.x = pitchAngle;
                ship.rotation.z = Math.sin(elapsed * 0.002) * 0.05 * (1 - progress); // Slight roll wobble

                // Update main particles - follow ship
                landingParticles.position.copy(ship.position);
                landingParticles.position.y += 150; // x5 speed
                landingParticles.rotation.y += 0.02;

                const positions = landingParticles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] += 40; // x5 speed
                    if (positions[i * 3 + 1] > 1250) { // x5 height
                        positions[i * 3 + 1] = 0;
                        positions[i * 3] = (Math.random() - 0.5) * 400; // x5 spread
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 400; // x5 spread
                    }
                }
                landingParticles.geometry.attributes.position.needsUpdate = true;
                particleMat.opacity = Math.max(0, 0.9 - progress * 1.3);

                // Update fire trail
                fireTrail.position.copy(ship.position);
                fireTrail.position.y += 250; // x5 speed
                fireTrail.rotation.x = -pitchAngle;
                trailMat.opacity = Math.max(0, 0.7 - progress * 1.0);

                // Update glows
                reentryGlow.position.copy(ship.position);
                glowMat.opacity = Math.max(0, 0.6 - progress * 0.9);
                reentryGlow.scale.setScalar(1 + Math.sin(elapsed * 0.015) * 0.3);

                coronaGlow.position.copy(ship.position);
                coronaMat.opacity = Math.max(0, 0.3 - progress * 0.5);
                coronaGlow.scale.setScalar(1.5 + Math.sin(elapsed * 0.01) * 0.4);

                // Update heat shield - visible during atmospheric entry
                heatShield.position.copy(ship.position);
                // Position shield in front of ship (nose)
                const shieldOffset = new THREE.Vector3(0, 0, -50); // Adjusted for nose length
                shieldOffset.applyEuler(ship.rotation);
                heatShield.position.add(shieldOffset);
                heatShield.rotation.copy(ship.rotation);
                heatShield.rotation.x += Math.PI / 2; // Face forward
                shieldMat.opacity = Math.max(0, 0.6 * (1 - progress * 1.5));
                heatShield.scale.setScalar(1 + Math.sin(elapsed * 0.02) * 0.15);
                // Color shift from red-orange to yellow as it heats up
                const heatIntensity = Math.max(0, 1 - progress * 1.2);
                shieldMat.color.setHSL(0.05 + heatIntensity * 0.03, 1, 0.5 + heatIntensity * 0.2);

                // Update shockwave - expanding ring around ship
                shockwave.position.copy(ship.position);
                shockwave.rotation.copy(ship.rotation);
                shockwave.rotation.x += Math.PI / 2;
                const shockScale = 1 + (elapsed * 0.001) % 3;
                shockwave.scale.setScalar(shockScale);
                shockwaveMat.opacity = Math.max(0, (0.3 - shockScale * 0.1) * (1 - progress));

                // EPIC CINEMATIC CAMERA WORK - 5 Phases
                if (progress < phases[0].end) {
                    // Phase 1: Space view - Camera far away, shows ship approaching planet
                    const phaseProgress = progress / phases[0].end;
                    const camDist = 10000 - phaseProgress * 2500; // x5
                    camera.position.set(
                        planetPos.x + camDist * 0.7,
                        planetPos.y + startHeight * 0.5 + phaseProgress * 2500, // x5 (offset part)
                        planetPos.z + camDist
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[1].end) {
                    // Phase 2: Atmospheric entry - Dramatic side angle
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const orbitAngle = phaseProgress * Math.PI * 0.4;
                    camera.position.set(
                        ship.position.x + Math.cos(orbitAngle + spiralAngle) * 2000, // x5
                        ship.position.y + 750 - phaseProgress * 250, // x5
                        ship.position.z + Math.sin(orbitAngle + spiralAngle) * 2000 // x5
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 65 + phaseProgress * 10;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[2].end) {
                    // Phase 3: Fireball - Close chase camera
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const camOffset = new THREE.Vector3(0, 300 + Math.sin(phaseProgress * Math.PI) * 150, 600); // x5
                    camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), ship.rotation.y);
                    camera.position.lerp(ship.position.clone().add(camOffset), 0.08);
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, -150, 0))); // x5 (-30 -> -150)
                    camera.fov = 75;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[3].end) {
                    // Phase 4: Cloud break - Dramatic flyby
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const flybyAngle = phaseProgress * Math.PI * 0.6;
                    camera.position.set(
                        ship.position.x + Math.sin(flybyAngle) * 1000, // x5
                        ship.position.y - 250 + Math.cos(flybyAngle * 2) * 400, // x5
                        ship.position.z + Math.cos(flybyAngle) * 1250 // x5
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 70 - phaseProgress * 5;
                    camera.updateProjectionMatrix();
                }
                else {
                    // Phase 5: Final descent - Low angle hero shot
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    camera.position.set(
                        ship.position.x + 400 * (1 - eased * 0.5), // x5
                        ship.position.y - 300 + eased * 500, // x5
                        ship.position.z + 600 - eased * 150 // x5
                    );
                    camera.lookAt(ship.position);
                    camera.fov = 65 + eased * 5;
                    camera.updateProjectionMatrix();
                }

                // Intense camera shake during atmospheric phases
                if (progress > 0.15 && progress < 0.7) {
                    const intensity = Math.sin((progress - 0.15) / 0.55 * Math.PI) * 25; // x5 intensity
                    camera.position.x += (Math.random() - 0.5) * intensity;
                    camera.position.y += (Math.random() - 0.5) * intensity;
                    camera.position.z += (Math.random() - 0.5) * intensity * 0.5;
                }

                // Animate engine flames with intensity
                const flameIntensity = 1 + (1 - progress) * 2;
                engineFlames.forEach((f, i) => {
                    f.scale.setScalar(flameIntensity + Math.sin(elapsed * 0.025 + i) * 0.6);
                });

                if (composer) composer.render();
                else renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateLanding);
                } else {
                    // Cleanup all cinematic elements
                    scene.remove(landingParticles);
                    scene.remove(reentryGlow);
                    scene.remove(coronaGlow);
                    scene.remove(fireTrail);
                    scene.remove(heatShield);
                    scene.remove(shockwave);

                    landingParticles.geometry.dispose();
                    landingParticles.material.dispose();
                    reentryGlow.geometry.dispose();
                    reentryGlow.material.dispose();
                    coronaGlow.geometry.dispose();
                    coronaMat.dispose();
                    fireTrail.geometry.dispose();
                    fireTrail.material.dispose();
                    heatShield.geometry.dispose();
                    shieldMat.dispose();
                    shockwave.geometry.dispose();
                    shockwaveMat.dispose();

                    landingParticles = null;
                    reentryGlow = null;
                    fireTrail = null;

                    // Reset camera FOV
                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    setTimeout(() => {
                        landingDiv.style.display = 'none';
                        landingText.classList.remove('show');
                        document.getElementById('hud').style.opacity = '1';
                        document.getElementById('crosshair').style.opacity = '1';
                        document.getElementById('prompt').style.opacity = '1';
                        isInCinematic = false;
                        if (callback) callback();
                    }, 500);
                }
            }

            requestAnimationFrame(animateLanding);
        }

        // TAKEOFF CINEMATIC - Epic departure from planet
        function playTakeoffCinematic(callback) {
            isInCinematic = true;

            const landingDiv = document.getElementById('landing-cinematic');
            const landingText = document.getElementById('landing-text');
            const heatGlow = document.getElementById('heat-glow');

            landingDiv.style.display = 'block';

            // Hide UI during cinematic
            document.getElementById('hud').style.opacity = '0';
            document.getElementById('crosshair').style.opacity = '0';
            document.getElementById('prompt').style.opacity = '0';
            document.getElementById('mission-panel').style.display = 'none';

            // Store starting position (on planet surface)
            const startPos = ship.position.clone();
            const targetHeight = 10000; // x3 height

            // Initialize ship rotation for takeoff - pointing straight up
            ship.rotation.order = 'YXZ';
            ship.rotation.x = 0;
            ship.rotation.y = 0;
            ship.rotation.z = 0;

            // Create takeoff particle effects (dust/thrust)
            const dustCount = 800; // More dust
            const dustGeo = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = [];

            for (let i = 0; i < dustCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 500; // x5 radius
                dustPositions[i * 3] = Math.cos(angle) * dist;
                dustPositions[i * 3 + 1] = Math.random() * 50; // Higher dust
                dustPositions[i * 3 + 2] = Math.sin(angle) * dist;
                dustVelocities.push({
                    x: (Math.random() - 0.5) * 8, // Faster expansion
                    y: Math.random() * 5 + 2,
                    z: (Math.random() - 0.5) * 8
                });
            }
            dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

            const dustMat = new THREE.PointsMaterial({
                color: currentPlanetObj.userData.atmosphereColor,
                size: 15, // Larger puffs
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const dustParticles = new THREE.Points(dustGeo, dustMat);
            dustParticles.position.copy(startPos);
            scene.add(dustParticles);

            // Create engine exhaust
            const exhaustCount = 300;
            const exhaustGeo = new THREE.BufferGeometry();
            const exhaustPositions = new Float32Array(exhaustCount * 3);

            for (let i = 0; i < exhaustCount; i++) {
                exhaustPositions[i * 3] = (Math.random() - 0.5) * 100; // Wider spread
                exhaustPositions[i * 3 + 1] = -Math.random() * 300; // Longer trail
                exhaustPositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
            exhaustGeo.setAttribute('position', new THREE.BufferAttribute(exhaustPositions, 3));

            const exhaustMat = new THREE.PointsMaterial({
                color: 0x00f0ff,
                size: 12, // Huge exhaust
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const exhaustParticles = new THREE.Points(exhaustGeo, exhaustMat);
            scene.add(exhaustParticles);

            // Create speed lines for atmosphere escape
            const speedLineCount = 200;
            const speedGeo = new THREE.BufferGeometry();
            const speedPositions = new Float32Array(speedLineCount * 6); // Lines have 2 points each

            for (let i = 0; i < speedLineCount; i++) {
                const x = (Math.random() - 0.5) * 2000; // Wider field
                const z = (Math.random() - 0.5) * 2000;
                speedPositions[i * 6] = x;
                speedPositions[i * 6 + 1] = Math.random() * 500;
                speedPositions[i * 6 + 2] = z;
                speedPositions[i * 6 + 3] = x;
                speedPositions[i * 6 + 4] = speedPositions[i * 6 + 1] + 150; // Longer lines
                speedPositions[i * 6 + 5] = z;
            }
            speedGeo.setAttribute('position', new THREE.BufferAttribute(speedPositions, 3));

            const speedMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            const speedLines = new THREE.LineSegments(speedGeo, speedMat);
            scene.add(speedLines);

            // Cinematic timing
            let cinematicStart = 0;
            const totalDuration = 8000;

            const phases = [
                { name: 'POWER_UP', start: 0, end: 0.15 },
                { name: 'LIFTOFF', start: 0.15, end: 0.35 },
                { name: 'ASCENT', start: 0.35, end: 0.6 },
                { name: 'ESCAPE', start: 0.6, end: 0.85 },
                { name: 'SPACE', start: 0.85, end: 1.0 }
            ];

            // Text phases
            landingText.textContent = 'âš¡ MISE SOUS TENSION';
            landingText.classList.add('show');

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸš€ DÃ‰COLLAGE';
                landingText.classList.add('show');
            }, 1200);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'â˜ï¸ SORTIE ATMOSPHÃ‰RIQUE';
                landingText.classList.add('show');
            }, 2800);

            setTimeout(() => {
                landingText.classList.remove('show');
                void landingText.offsetWidth;
                landingText.textContent = 'ðŸŒŒ ESPACE PROFOND';
                landingText.classList.add('show');
            }, 5000);

            function animateTakeoff(timestamp) {
                if (cinematicStart === 0) cinematicStart = timestamp;
                const elapsed = timestamp - cinematicStart;
                const progress = Math.min(elapsed / totalDuration, 1);

                const easeIn = t => t * t * t;
                const easeOut = t => 1 - Math.pow(1 - t, 3);
                const easeInOut = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                // Ship movement
                if (progress < phases[0].end) {
                    // Power up - ship vibrates
                    const phaseProgress = progress / phases[0].end;
                    const shake = phaseProgress * 0.5;
                    ship.position.x = startPos.x + (Math.random() - 0.5) * shake;
                    ship.position.z = startPos.z + (Math.random() - 0.5) * shake;
                    ship.position.y = startPos.y + phaseProgress * 5;
                }
                else if (progress < phases[1].end) {
                    // Liftoff - slow rise
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    const eased = easeIn(phaseProgress);
                    ship.position.y = startPos.y + 5 + eased * 200;
                    ship.rotation.x = -eased * 0.3;
                }
                else if (progress < phases[2].end) {
                    // Ascent - accelerating
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    const eased = easeInOut(phaseProgress);
                    ship.position.y = startPos.y + 205 + eased * 1000;
                    ship.rotation.x = -0.3 - eased * 0.5;
                }
                else if (progress < phases[3].end) {
                    // Escape - breaking atmosphere
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    const eased = easeIn(phaseProgress);
                    ship.position.y = startPos.y + 1205 + eased * 1500;
                    ship.rotation.x = -0.8 - eased * 0.2;
                    speedMat.opacity = phaseProgress * 0.5;
                }
                else {
                    // Space - final position
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    ship.position.y = startPos.y + 2705 + eased * 300;
                    ship.rotation.x = -1 + eased * 1;
                    speedMat.opacity = (1 - eased) * 0.5;
                }

                // Update dust particles (ground effect)
                if (progress < 0.4) {
                    const dustArray = dustParticles.geometry.attributes.position.array;
                    for (let i = 0; i < dustCount; i++) {
                        dustArray[i * 3] += dustVelocities[i].x * (1 - progress * 2);
                        dustArray[i * 3 + 1] += dustVelocities[i].y;
                        dustArray[i * 3 + 2] += dustVelocities[i].z * (1 - progress * 2);
                    }
                    dustParticles.geometry.attributes.position.needsUpdate = true;
                    dustMat.opacity = Math.max(0, 0.6 - progress * 2);
                }

                // Update exhaust
                exhaustParticles.position.copy(ship.position);
                const exhaustArray = exhaustParticles.geometry.attributes.position.array;
                for (let i = 0; i < exhaustCount; i++) {
                    exhaustArray[i * 3 + 1] -= 10;
                    if (exhaustArray[i * 3 + 1] < -150) {
                        exhaustArray[i * 3 + 1] = 0;
                        exhaustArray[i * 3] = (Math.random() - 0.5) * 30;
                        exhaustArray[i * 3 + 2] = (Math.random() - 0.5) * 30;
                    }
                }
                exhaustParticles.geometry.attributes.position.needsUpdate = true;
                exhaustMat.opacity = 0.8 - progress * 0.3;

                // Update speed lines
                speedLines.position.copy(ship.position);

                // CINEMATIC CAMERA
                if (progress < phases[0].end) {
                    // Power up - dramatic low angle
                    camera.position.set(
                        ship.position.x + 400, // x5
                        ship.position.y - 100, // x5
                        ship.position.z + 500 // x5
                    );
                    camera.lookAt(ship.position);
                }
                else if (progress < phases[1].end) {
                    // Liftoff - rising with ship
                    const phaseProgress = (progress - phases[1].start) / (phases[1].end - phases[1].start);
                    camera.position.set(
                        ship.position.x + 500 - phaseProgress * 100, // x5
                        ship.position.y - 150 + phaseProgress * 100, // x5
                        ship.position.z + 600 // x5
                    );
                    camera.lookAt(ship.position);
                }
                else if (progress < phases[2].end) {
                    // Ascent - chase camera
                    const phaseProgress = (progress - phases[2].start) / (phases[2].end - phases[2].start);
                    camera.position.set(
                        ship.position.x + 250, // x5
                        ship.position.y + 150, // x5
                        ship.position.z + 750 // x5
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, 500, 0))); // x5
                    camera.fov = 70 + phaseProgress * 15;
                    camera.updateProjectionMatrix();
                }
                else if (progress < phases[3].end) {
                    // Escape - behind and below 
                    const phaseProgress = (progress - phases[3].start) / (phases[3].end - phases[3].start);
                    camera.position.set(
                        ship.position.x,
                        ship.position.y + 250, // x5
                        ship.position.z + 900 // x5
                    );
                    camera.lookAt(ship.position.clone().add(new THREE.Vector3(0, -1000, 0))); // x5
                    camera.fov = 85 - phaseProgress * 10;
                    camera.updateProjectionMatrix();
                }
                else {
                    // Space - settling behind
                    const phaseProgress = (progress - phases[4].start) / (phases[4].end - phases[4].start);
                    const eased = easeOut(phaseProgress);
                    camera.position.lerp(ship.position.clone().add(new THREE.Vector3(0, 75, 325)), 0.05); // x5
                    camera.lookAt(ship.position);
                    camera.fov = 75 - eased * 5;
                    camera.updateProjectionMatrix();
                }

                // Camera shake during thrust
                if (progress > 0.1 && progress < 0.7) {
                    const intensity = 15 * (1 - progress); // x5
                    camera.position.x += (Math.random() - 0.5) * intensity;
                    camera.position.y += (Math.random() - 0.5) * intensity;
                }

                // Engine flames intense during takeoff
                const flameIntensity = 2 + progress * 2;
                engineFlames.forEach((f, i) => {
                    f.scale.setScalar(flameIntensity + Math.sin(elapsed * 0.03 + i) * 0.8);
                });

                if (composer) composer.render();
                else renderer.render(scene, camera);

                if (progress < 1) {
                    requestAnimationFrame(animateTakeoff);
                } else {
                    // Cleanup
                    scene.remove(dustParticles);
                    scene.remove(exhaustParticles);
                    scene.remove(speedLines);

                    dustGeo.dispose();
                    dustMat.dispose();
                    exhaustGeo.dispose();
                    exhaustMat.dispose();
                    speedGeo.dispose();
                    speedMat.dispose();

                    camera.fov = 70;
                    camera.updateProjectionMatrix();

                    // End cinematic
                    setTimeout(() => {
                        landingDiv.style.display = 'none';
                        landingText.classList.remove('show');
                        document.getElementById('hud').style.opacity = '1';
                        document.getElementById('crosshair').style.opacity = '1';
                        document.getElementById('prompt').style.opacity = '1';
                        isInCinematic = false;
                        if (callback) callback();
                    }, 500);
                }
            }

            requestAnimationFrame(animateTakeoff);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100000);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            scene.add(new THREE.AmbientLight(0x111122, 0.2)); // Reduced ambient, use hemisphere

            // Richer lighting for metallic materials
            const hemiLight = new THREE.HemisphereLight(0x0000ff, 0x00ff00, 0.3); // Blue sky, Greenish ground reflection
            scene.add(hemiLight);

            const sun = new THREE.DirectionalLight(0xffffff, 2.0); // Reduced from 3.0
            sun.position.set(2000, 2000, 2000);
            sun.castShadow = true;
            scene.add(sun);

            createStars();
            ship = createTitanShip();
            scene.add(ship);
            ship.position.set(0, 0, 1500);

            createHDPlanet("MOLTEN-X", "#ff3300", 400, new THREE.Vector3(3000, 0, -4000), 0xff4400, "Collecter 5 cristaux de lave");
            createHDPlanet("NEPTUNE-PRO", "#0088ff", 450, new THREE.Vector3(-6000, 800, -8000), 0x00ffff, "DÃ©truire 3 antennes alien");
            createHDPlanet("KRYPTON-ELITE", "#44ff44", 350, new THREE.Vector3(0, -2000, -12000), 0x44ff88, "Scanner 4 monolithes anciens");

            window.addEventListener('keydown', e => {
                keys[e.code] = true;
                if (e.code === 'Space' && !isInCinematic) shoot(); // Fallback trigger
                if (e.code === 'KeyE' && !isInCinematic) tryInteract();
            });
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => {
                console.log("MOUSE DOWN DETECTED. GameStarted:", gameStarted, "Locked:", isLocked, "Cinematic:", isInCinematic);
                if (!gameStarted) return;
                if (!isLocked) document.body.requestPointerLock();
                else if (!isInCinematic) shoot();
            });
            document.addEventListener('pointerlockchange', () => isLocked = document.pointerLockElement === document.body);

            // Start intro cinematic
            startIntroCinematic();

            // BLOOM POST-PROCESSING
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0.85; // High threshold to avoid planet ground blooming
            bloomPass.strength = 0.8; // Reduced strength
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            animate();
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 30000; i++) {
                pos.push((Math.random() - 0.5) * 100000, (Math.random() - 0.5) * 100000, (Math.random() - 0.5) * 100000);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 2, transparent: true, opacity: 0.7 });
            scene.add(new THREE.Points(starGeo, starMat));
        }

        function createShip() {
            const shipGroup = new THREE.Group();

            // 1. ADVANCED MATERIALS
            const metalTex = createMetallicTexture();
            const hullMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                map: metalTex,
                roughness: 0.3,
                metalness: 0.8,
                envMapIntensity: 1.5,
                bumpMap: metalTex,
                bumpScale: 0.05
            });

            const darkMetalMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                map: metalTex,
                roughness: 0.5,
                metalness: 0.6,
                bumpMap: metalTex,
                bumpScale: 0.02
            });

            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00aaff,
                metalness: 0.1,
                roughness: 0.0,
                transmission: 0.9,
                transparent: true,
                opacity: 0.6,
                reflectivity: 1.0,
                clearcoat: 1.0
            });

            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
            const engineGlowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });

            // 2. FUSELAGE (Main Body)
            // Central body composed of multiple sections
            const noseGeo = new THREE.ConeGeometry(0.8, 4, 32);
            const nose = new THREE.Mesh(noseGeo, hullMat);
            nose.rotation.x = -Math.PI / 2;
            nose.position.z = -5;
            shipGroup.add(nose);

            const mainBodyGeo = new THREE.CylinderGeometry(1.2, 0.8, 6, 32);
            const mainBody = new THREE.Mesh(mainBodyGeo, hullMat);
            mainBody.rotation.x = Math.PI / 2;
            mainBody.position.z = 0;
            shipGroup.add(mainBody);

            const rearSectionGeo = new THREE.BoxGeometry(3, 1.5, 4);
            const rearSection = new THREE.Mesh(rearSectionGeo, darkMetalMat);
            rearSection.position.z = 4;
            shipGroup.add(rearSection);

            // 3. COCKPIT
            const cockpitGeo = new THREE.Group();
            // Canopy
            const canopyGeo = new THREE.CapsuleGeometry(0.9, 2, 4, 16);
            const canopy = new THREE.Mesh(canopyGeo, glassMat);
            canopy.rotation.x = Math.PI / 2;
            canopy.position.set(0, 0.5, -1);
            canopy.scale.set(1, 0.8, 1);
            cockpitGeo.add(canopy);

            // Interior details (Pilot seat hint)
            const seatGeo = new THREE.BoxGeometry(0.6, 0.8, 0.6);
            const seat = new THREE.Mesh(seatGeo, darkMetalMat);
            seat.position.set(0, 0.2, -0.5);
            cockpitGeo.add(seat);

            shipGroup.add(cockpitGeo);

            // 4. WINGS (Fixed Alignment)
            // Using simpler geometry to ensure straightness
            const wingGeo = new THREE.BoxGeometry(10, 0.2, 5);
            const wings = new THREE.Mesh(wingGeo, hullMat);
            wings.position.set(0, 0, 1);
            shipGroup.add(wings);

            // Wing Tips (Vertical)
            const tipGeo = new THREE.BoxGeometry(0.2, 1.5, 3);
            const leftTip = new THREE.Mesh(tipGeo, darkMetalMat);
            leftTip.position.set(-5, 0.5, 1);
            shipGroup.add(leftTip);

            const rightTip = new THREE.Mesh(tipGeo, darkMetalMat);
            rightTip.position.set(5, 0.5, 1);
            shipGroup.add(rightTip);

            // Vertical Stabilizer (Central Tail)
            const tailGeo = new THREE.BoxGeometry(0.2, 4, 3);
            const tail = new THREE.Mesh(tailGeo, hullMat);
            tail.position.set(0, 2, 4.5);
            shipGroup.add(tail);

            // 5. ENGINES (Turbines & Glow)
            const engineGeo = new THREE.CylinderGeometry(0.8, 1.2, 4, 16, 1, true);

            const leftEngine = new THREE.Mesh(engineGeo, darkMetalMat);
            leftEngine.rotation.x = Math.PI / 2;
            leftEngine.position.set(-3.5, 0, 3);
            shipGroup.add(leftEngine);

            const rightEngine = new THREE.Mesh(engineGeo, darkMetalMat);
            rightEngine.rotation.x = Math.PI / 2;
            rightEngine.position.set(3.5, 0, 3);
            shipGroup.add(rightEngine);

            // Turbine blades glow
            const turbineGeo = new THREE.RingGeometry(0.2, 0.7, 8);
            const turbineMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, side: THREE.DoubleSide });

            const leftTurbine = new THREE.Mesh(turbineGeo, turbineMat);
            leftTurbine.position.set(0, -1.8, 0); // Inside engine
            leftTurbine.rotation.x = Math.PI / 2;
            leftEngine.add(leftTurbine);

            const rightTurbine = new THREE.Mesh(turbineGeo, turbineMat);
            rightTurbine.position.set(0, -1.8, 0);
            rightTurbine.rotation.x = Math.PI / 2;
            rightEngine.add(rightTurbine);

            // Engine Flames (Visuals linked to particles later)
            for (let i = 0; i < 2; i++) {
                // Main flame core
                const flameGeo = new THREE.ConeGeometry(0.5, 6, 16);
                const flame = new THREE.Mesh(flameGeo, new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                }));
                flame.rotation.x = -Math.PI / 2;
                // Position relative to shipGroup
                flame.position.set(i === 0 ? -3.5 : 3.5, 0, 6.5);
                engineFlames.push(flame);
                shipGroup.add(flame);

                // Outer Glow
                const glowGeo = new THREE.ConeGeometry(1.2, 8, 16);
                const glow = new THREE.Mesh(glowGeo, new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                }));
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(i === 0 ? -3.5 : 3.5, 0, 7);
                engineFlames.push(glow);
                shipGroup.add(glow);
            }

            // 6. GREEBLES (Technical Details)
            // Add vents and pipes
            const ventGeo = new THREE.BoxGeometry(0.5, 0.1, 1);
            for (let i = 0; i < 4; i++) {
                const vent = new THREE.Mesh(ventGeo, darkMetalMat);
                vent.position.set(0, 0.85, -1 + i * 0.8);
                shipGroup.add(vent);
            }

            // Side pipes
            const pipeGeo = new THREE.CylinderGeometry(0.1, 0.1, 8, 8);
            const leftPipe = new THREE.Mesh(pipeGeo, hullMat);
            leftPipe.rotation.x = Math.PI / 2;
            leftPipe.position.set(-1, -0.5, 0);
            shipGroup.add(leftPipe);

            const rightPipe = new THREE.Mesh(pipeGeo, hullMat);
            rightPipe.rotation.x = Math.PI / 2;
            rightPipe.position.set(1, -0.5, 0);
            shipGroup.add(rightPipe);

            // Navigation Lights (Blinkers)
            const navLightGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const redLight = new THREE.Mesh(navLightGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            redLight.position.set(-6, 0.2, -1); // Left Wingtip
            shipGroup.add(redLight);

            const greenLight = new THREE.Mesh(navLightGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            greenLight.position.set(6, 0.2, -1); // Right Wingtip
            shipGroup.add(greenLight);

            // Blink animation logic
            setInterval(() => {
                redLight.visible = !redLight.visible;
                greenLight.visible = !greenLight.visible;
            }, 1000);

            return shipGroup;
        }

        function createHDPlanet(name, color, size, pos, atmosphereColor, missionDesc) {
            const group = new THREE.Group();
            const tex = createPlanetTexture(color);
            const mat = new THREE.MeshStandardMaterial({
                map: tex,
                bumpMap: tex,
                bumpScale: 6,
                roughness: 0.85,
                metalness: 0.1
            });
            const pMesh = new THREE.Mesh(new THREE.SphereGeometry(size, 128, 128), mat);
            group.add(pMesh);

            const clouds = new THREE.Mesh(
                new THREE.SphereGeometry(size * 1.03, 64, 64),
                new THREE.MeshStandardMaterial({
                    map: createPlanetTexture('rgba(255,255,255,0.1)'),
                    transparent: true,
                    opacity: 0.3
                })
            );
            group.add(clouds);

            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(size * 1.2, 64, 64),
                new THREE.MeshBasicMaterial({
                    color: atmosphereColor,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                })
            );
            group.add(glow);

            group.position.copy(pos);
            group.userData = { name, size, atmosphereColor, clouds, color, missionDesc };
            scene.add(group);
            planets.push(group);

            // Ennemis gardiens (RÃ©duit Ã  1 pour la difficultÃ©)
            for (let i = 0; i < 1; i++) {
                const enemy = createEnemyShip();
                enemy.position.copy(pos).add(new THREE.Vector3((Math.random() - 0.5) * 3000, (Math.random() - 0.5) * 3000, (Math.random() - 0.5) * 3000));
                enemy.userData = { hp: 20, home: pos.clone(), lastShot: 0, planet: name };
                enemies.push(enemy);
                scene.add(enemy);
            }
        }

        function createEnemyShip() {
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.9, roughness: 0.1 });
            const hull = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 1.2, 8, 8), mat);
            hull.rotation.x = Math.PI / 2;
            const wings = new THREE.Mesh(new THREE.BoxGeometry(10, 0.3, 3), mat);
            g.add(hull, wings);
            return g;
        }

        function startMission(planet) {
            planetEnvironment.children.forEach(c => {
                if (c.userData && c.userData.type) planetEnvironment.remove(c);
            });
            missionObjects = [];
            collectedItems = 0;
            planetMissionStage = 0;

            const missionData = {
                "MOLTEN-X": {
                    desc: "PHASE 1: Refroidir 3 Ã©vents de vapeur",
                    spawn: () => spawnVents(3)
                },
                "NEPTUNE-PRO": {
                    desc: "PHASE 1: Pirater 2 terminaux de donnÃ©es",
                    spawn: () => spawnTerminals(2)
                },
                "KRYPTON-ELITE": {
                    desc: "PHASE 1: Activer 3 pylÃ´nes d'Ã©nergie",
                    spawn: () => spawnPylons(3)
                }
            };

            const mission = missionData[planet.userData.name];
            mission.spawn();

            // QUEST STAGE OVERRIDES
            if (questStage === 2 && planet.userData.name === "NEPTUNE-PRO") spawnCipher();
            if (questStage === 3 && planet.userData.name === "MOLTEN-X") spawnPowerCores(5);

            currentMission = {
                name: planet.userData.name,
                desc: mission.desc,
                total: missionObjects.length,
                collected: 0
            };

            document.getElementById('objective-title').innerText = "MISSION : " + currentMission.name;
            document.getElementById('objective-desc').innerText = currentMission.desc;
        }

        function advancePlanetMission() {
            planetMissionStage++;
            missionObjects = [];
            collectedItems = 0;

            if (currentMission.name === "MOLTEN-X") {
                currentMission.desc = "PHASE 2: Extraire le Noyau de Lave";
                spawnCrystals(1, 0xff6600); // One big core
            } else if (currentMission.name === "NEPTUNE-PRO") {
                currentMission.desc = "PHASE 2: DÃ©truire l'Antenne MaÃ®tresse";
                spawnAntennes(1, 0x0088ff);
            } else if (currentMission.name === "KRYPTON-ELITE") {
                currentMission.desc = "PHASE 2: Scanner le Monolithe Central";
                spawnMonolithes(1, 0x44ff44);
            }

            currentMission.total = missionObjects.length;
            document.getElementById('objective-desc').innerText = currentMission.desc;
            showNotification("NOUVEL OBJECTIF : " + currentMission.desc);
        }

        function spawnVents(count) {
            for (let i = 0; i < count; i++) {
                const vent = new THREE.Mesh(
                    new THREE.CylinderGeometry(40, 60, 10, 16),
                    new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9 })
                );
                const rx = (Math.random() - 0.5) * 5000;
                const rz = (Math.random() - 0.5) * 5000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                vent.position.set(rx, ry + 5, rz);
                vent.userData.type = 'vent';
                vent.userData.cooled = false;

                // Steam particle effect
                const steam = createParticleRing(vent.position, 0xffffff);
                steam.scale.set(0.5, 2, 0.5);
                vent.add(steam);
                vent.userData.steam = steam;

                planetEnvironment.add(vent);
                missionObjects.push(vent);
            }
        }

        function spawnTerminals(count) {
            for (let i = 0; i < count; i++) {
                const term = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(20, 40, 10), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(15, 10), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                screen.position.set(0, 5, 5.1);
                term.add(body, screen);

                const rx = (Math.random() - 0.5) * 5000;
                const rz = (Math.random() - 0.5) * 5000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                term.position.set(rx, ry + 20, rz);
                term.userData.type = 'terminal';
                term.userData.hacked = false;
                planetEnvironment.add(term);
                missionObjects.push(term);
            }
        }

        function spawnPylons(count) {
            for (let i = 0; i < count; i++) {
                const pylon = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 5, 100),
                    new THREE.MeshStandardMaterial({ color: 0x444444 })
                );
                const rx = (Math.random() - 0.5) * 5000;
                const rz = (Math.random() - 0.5) * 5000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                pylon.position.set(rx, ry + 50, rz);
                pylon.userData.type = 'pylon';
                pylon.userData.active = false;
                planetEnvironment.add(pylon);
                missionObjects.push(pylon);
            }
        }

        function spawnCrystals(count, color) {
            for (let i = 0; i < count; i++) {
                const crystal = new THREE.Mesh(
                    new THREE.ConeGeometry(20, 50, 6),
                    new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    })
                );
                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                crystal.position.set(rx, ry + 25, rz);
                crystal.rotation.z = Math.random() * Math.PI * 2;
                crystal.userData.type = 'collectible';
                planetEnvironment.add(crystal);
                missionObjects.push(crystal);

                // Particules autour
                const particles = createParticleRing(crystal.position, color);
                planetEnvironment.add(particles);
            }
        }

        function spawnAntennes(count, color) {
            for (let i = 0; i < count; i++) {
                const base = new THREE.Group();
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 8, 80, 8),
                    new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 })
                );
                const dish = new THREE.Mesh(
                    new THREE.CylinderGeometry(30, 25, 10, 16),
                    new THREE.MeshStandardMaterial({ color: color, metalness: 0.9 })
                );
                dish.position.y = 45;
                base.add(pole, dish);

                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                base.position.set(rx, ry + 40, rz);
                base.userData.type = 'destroyable';
                base.userData.hp = 3;
                planetEnvironment.add(base);
                missionObjects.push(base);
            }
        }

        function spawnMonolithes(count, color) {
            for (let i = 0; i < count; i++) {
                const monolith = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 100, 20),
                    new THREE.MeshStandardMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        metalness: 0.5,
                        roughness: 0.3
                    })
                );
                const rx = (Math.random() - 0.5) * 6000;
                const rz = (Math.random() - 0.5) * 6000;
                const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                monolith.position.set(rx, ry + 50, rz);
                monolith.userData.type = 'scannable';
                monolith.userData.scanned = false;
                planetEnvironment.add(monolith);
                missionObjects.push(monolith);

                // Runes lumineuses
                for (let j = 0; j < 5; j++) {
                    const rune = new THREE.Mesh(
                        new THREE.PlaneGeometry(8, 8),
                        new THREE.MeshBasicMaterial({
                            color: color,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    rune.position.set(0, -40 + j * 20, 10.5);
                    monolith.add(rune);
                }
            }
        }

        function createParticleRing(pos, color) {
            const geo = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 50; i++) {
                const angle = (i / 50) * Math.PI * 2;
                positions.push(
                    Math.cos(angle) * 30,
                    Math.sin(i * 0.5) * 10,
                    Math.sin(angle) * 30
                );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: color,
                size: 5,
                transparent: true,
                opacity: 0.6
            });
            return new THREE.Points(geo, mat);
        }

        function checkMissionObjectInteraction() {
            missionObjects.forEach((obj, index) => {
                const dist = camera.position.distanceTo(obj.position);

                if (obj.userData.type === 'collectible' && dist < 100) {
                    planetEnvironment.remove(obj);
                    missionObjects.splice(index, 1);
                    collectedItems++;
                    score += 100;
                    document.getElementById('score').innerText = "PRIME : " + score;
                    updateMissionProgress();
                    showNotification('âœ… CRISTAL COLLECTÃ‰ !');
                }

                if (obj.userData.type === 'scannable' && !obj.userData.scanned && dist < 150) {
                    document.getElementById('prompt').innerText = "[E] SCANNER LE MONOLITHE";
                }

                if (obj.userData.type === 'destroyable' && dist < 200) {
                    document.getElementById('prompt').innerText = "[CLIC] DÃ‰TRUIRE L'ANTENNE";
                }
            });
        }

        function updateMissionProgress() {
            if (!currentMission) return;
            currentMission.collected = collectedItems;

            // Check Phase completion
            if (collectedItems >= currentMission.total) {
                if (planetMissionStage === 0) {
                    advancePlanetMission();
                } else {
                    setTimeout(() => {
                        showNotification('ðŸŽ‰ MISSION ACCOMPLIE ! +500 PRIME');
                        credits += 500;
                        document.getElementById('score').innerText = "CREDITS : " + credits;
                        currentMission = null;
                        missionObjects = [];
                        document.getElementById('objective-desc').innerText = "EXPLORATION TERMINÃ‰E";
                    }, 500);
                }
            }
        }

        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.innerText = text;
            notif.style.display = 'block';
            setTimeout(() => {
                notif.style.display = 'none';
            }, 3000);
        }

        function startLanding(p) {
            currentPlanetObj = p;

            // Play 3D landing cinematic - the callback fires when cinematic ends
            playLandingCinematic(p, () => {
                // Transition to planet mode after cinematic
                document.getElementById('fade').style.opacity = 1;

                setTimeout(() => {
                    currentMode = 'PLANET';
                    planets.forEach(pl => pl.visible = (pl === p));
                    enemies.forEach(e => e.visible = false);

                    planetEnvironment = new THREE.Group();

                    const groundSize = 12000;
                    const segments = 128;
                    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, segments, segments);

                    const posAttr = groundGeo.attributes.position;
                    for (let i = 0; i < posAttr.count; i++) {
                        const x = posAttr.getX(i);
                        const y = posAttr.getY(i);
                        const z = (Math.sin(x / 500) * Math.cos(y / 500) * 200) + (Math.sin(x / 100) * 30);
                        posAttr.setZ(i, z);
                    }
                    groundGeo.computeVertexNormals();

                    const groundTex = createPlanetTexture(p.userData.color, true);
                    const groundMat = new THREE.MeshStandardMaterial({
                        map: groundTex,
                        bumpMap: groundTex,
                        bumpScale: 10,
                        roughness: 0.9
                    });
                    const ground = new THREE.Mesh(groundGeo, groundMat);
                    ground.rotation.x = -Math.PI / 2;
                    planetEnvironment.add(ground);

                    const rockGeo = new THREE.IcosahedronGeometry(15, 1);
                    for (let i = 0; i < 150; i++) {
                        const rock = new THREE.Mesh(rockGeo, groundMat);
                        const rx = (Math.random() - 0.5) * 8000;
                        const rz = (Math.random() - 0.5) * 8000;
                        const ry = (Math.sin(rx / 500) * Math.cos(rz / 500) * 200) + (Math.sin(rx / 100) * 30);
                        rock.position.set(rx, ry + 5, rz);
                        rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                        rock.scale.setScalar(Math.random() * 3 + 1);
                        planetEnvironment.add(rock);
                    }

                    scene.fog = new THREE.FogExp2(p.userData.atmosphereColor, 0.0004);
                    scene.add(planetEnvironment);

                    ship.scale.set(10, 10, 10);
                    ship.position.set(0, 100, 0);
                    camera.position.set(100, 150, 100);

                    document.getElementById('location').innerText = p.userData.name;
                    document.getElementById('questStatus').innerText = 'EXPLORATION ACTIVE';

                    // Fade back and start mission
                    setTimeout(() => {
                        document.getElementById('fade').style.opacity = 0;
                        startMission(p);
                    }, 500);
                }, 800);
            });
        }

        function exitPlanet() {
            // Clear mission state first
            missionObjects = [];
            currentMission = null;

            // Play takeoff cinematic
            playTakeoffCinematic(() => {
                // After cinematic, transition to space
                document.getElementById('fade').style.opacity = 1;

                setTimeout(() => {
                    currentMode = 'SPACE';
                    scene.remove(planetEnvironment);
                    scene.fog = null;
                    planets.forEach(pl => pl.visible = true);
                    enemies.forEach(e => e.visible = true);
                    ship.scale.set(1, 1, 1);
                    ship.rotation.set(0, 0, 0);
                    ship.position.copy(currentPlanetObj.position).add(new THREE.Vector3(0, 0, 5000)); // x5
                    camera.position.copy(ship.position).add(new THREE.Vector3(0, 75, 325)); // x5
                    shipRot.yaw = 0;
                    shipRot.pitch = 0;
                    document.getElementById('location').innerText = "ESPACE PROFOND";
                    document.getElementById('questStatus').innerText = 'SCAN SECTEUR';

                    setTimeout(() => {
                        document.getElementById('fade').style.opacity = 0;
                    }, 300);
                }, 500);
            });
        }

        function onMouseMove(e) {
            if (!isLocked) return;
            const s = 0.002;
            if (currentMode === 'SPACE') {
                shipRot.yaw -= e.movementX * s;
                shipRot.pitch -= e.movementY * s;
            } else {
                playerRot.yaw -= e.movementX * s;
                playerRot.pitch = Math.max(-1.5, Math.min(1.5, playerRot.pitch - e.movementY * s));
            }
        }

        function shoot() {
            // Determine laser count based on upgrade
            const shotCount = (upgrades.laserLevel > 1) ? 2 : 1;
            const laserColor = (upgrades.laserLevel > 1) ? 0xff00ff : 0x00f0ff; // Purple lasers for upgrade

            for (let k = 0; k < shotCount; k++) {
                // MASSIVE LASER BEAM
                const laserGeo = new THREE.CylinderGeometry(3, 3, 600, 8);
                laserGeo.rotateX(Math.PI / 2);
                const laser = new THREE.Mesh(laserGeo, new THREE.MeshBasicMaterial({
                    color: laserColor,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.9
                }));
                const dir = new THREE.Vector3();

                if (currentMode === 'SPACE') {
                    // Parallax Correction: Shoot towards where the camera is looking
                    const crosshairDist = 3000;
                    const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const targetPoint = camera.position.clone().add(camDir.multiplyScalar(crosshairDist));

                    let offset = (k === 0) ? -15 : 15;
                    if (shotCount === 1) offset = 0;
                    const spawnPos = ship.position.clone().add(new THREE.Vector3(offset, 0, 0).applyQuaternion(ship.quaternion));

                    laser.position.copy(spawnPos);

                    // Direction is from Ship -> Target
                    dir.subVectors(targetPoint, spawnPos).normalize();
                    laser.lookAt(targetPoint);
                } else {
                    laser.position.copy(camera.position).add(new THREE.Vector3((k - 0.5) * 2, -1, 0).applyQuaternion(camera.quaternion));
                    laser.quaternion.copy(camera.quaternion);
                    dir.set(0, 0, -1).applyQuaternion(camera.quaternion);
                }

                scene.add(laser);

                // Closure for laser movement
                (function (l, d) {
                    let frames = 0;
                    function move() {
                        l.position.addScaledVector(d, 400); // EXTREMELY FAST

                        // Space Interceptors Collision
                        if (currentMode === 'SPACE') {
                            spaceEnemies.forEach((en, i) => {
                                if (l.position.distanceTo(en.position) < 300) { // GENEROUS HITBOX (was 100)
                                    en.userData.hp--;

                                    // Visual Hit Effect
                                    en.children.forEach(c => {
                                        if (c.material && c.material.emissive) c.material.emissive.setHex(0xffffff);
                                    });
                                    setTimeout(() => {
                                        en.children.forEach(c => {
                                            if (c.material && c.material.emissive) c.material.emissive.setHex(0x330000);
                                        });
                                    }, 50);

                                    if (en.userData.hp <= 0) {
                                        credits += 300; // Bounty
                                        document.getElementById('score').innerText = "CREDITS : " + credits;
                                        // Explosion effect could be added here
                                        scene.remove(en);
                                        spaceEnemies.splice(i, 1);
                                        // Notification removed per user request
                                    }
                                    scene.remove(l);
                                    return;
                                }
                            });
                        }

                        // Ground Enemies Collision
                        enemies.forEach((en, i) => {
                            if (l.position.distanceTo(en.position) < 50) { // Tighter hitbox
                                en.userData.hp--;
                                if (en.userData.hp <= 0) {
                                    credits += 50;
                                    document.getElementById('score').innerText = "CREDITS : " + credits;
                                    scene.remove(en);
                                    enemies.splice(i, 1);
                                }
                                scene.remove(l);
                                return;
                            }
                        });

                        missionObjects.forEach((obj, i) => {
                            if (obj.userData.type === 'destroyable' && l.position.distanceTo(obj.position) < 200) {
                                obj.userData.hp--;
                                if (obj.userData.hp <= 0) {
                                    planetEnvironment.remove(obj);
                                    missionObjects.splice(i, 1);
                                    collectedItems++;
                                    credits += 150;
                                    document.getElementById('score').innerText = "CREDITS : " + credits;
                                    updateMissionProgress();
                                    showNotification('ðŸ’¥ ANTENNE DÃ‰TRUITE !');

                                    // 50% chance of ambush
                                    if (Math.random() < 0.5) spawnAmbush(obj.position);
                                }
                                scene.remove(l);
                                return;
                            }
                        });

                        if (frames++ < 60) requestAnimationFrame(move);
                        else scene.remove(l);
                    } move();
                })(laser, dir);
            }
        }

        function enemyShoot(enemy) {
            const laser = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 20), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            laser.position.copy(enemy.position);
            laser.lookAt(ship.position);
            scene.add(laser);

            const dir = new THREE.Vector3().subVectors(ship.position, enemy.position).normalize();
            let frames = 0;
            function move() {
                laser.position.addScaledVector(dir, 40);

                if (currentMode === 'SPACE' && laser.position.distanceTo(ship.position) < 250) { // x5 hitbox
                    takeDamage(15); // Damage 5 -> 15 (Hardcore)
                    scene.remove(laser);
                    return;
                }

                if (frames++ < 50) requestAnimationFrame(move);
                else scene.remove(laser);
            } move();
        }

        function takeDamage(val) {
            health -= val;
            document.getElementById('health-bar').style.width = health + "%";
            document.getElementById('damage-overlay').style.backgroundColor = "rgba(255,0,0,0.3)";
            setTimeout(() => { document.getElementById('damage-overlay').style.backgroundColor = "transparent"; }, 150);
            if (health <= 0) {
                alert("GAME OVER - VAISSEAU DÃ‰TRUIT");
                location.reload();
            }
        }

        function tryInteract() {
            if (currentMode === 'SPACE') {
                planets.forEach(p => {
                    if (ship.position.distanceTo(p.position) < p.userData.size + 4000) startLanding(p); // x5 interact dist
                });
            } else {
                if (camera.position.distanceTo(ship.position) < 750) { // x5 interact dist
                    exitPlanet();
                } else {
                    missionObjects.forEach(obj => {
                        if (obj.userData.type === 'scannable' && !obj.userData.scanned && camera.position.distanceTo(obj.position) < 150) {
                            obj.userData.scanned = true;
                            collectedItems++;
                            score += 120;
                            document.getElementById('score').innerText = "PRIME : " + score;
                            updateMissionProgress();
                            showNotification('ðŸ” MONOLITHE SCANNÃ‰ !');

                            // 50% chance of ambush
                            if (Math.random() < 0.5) spawnAmbush(ship.position);

                            obj.traverse(child => {
                                if (child.isMesh && child.material.emissive) {
                                    child.material.emissiveIntensity = 1;
                                }
                            });
                        }
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Skip game logic during cinematics
            if (isInCinematic || !gameStarted) {
                if (composer) composer.render();
                else renderer.render(scene, camera);
                return;
            }

            if (isLocked) {
                if (currentMode === 'SPACE') {
                    ship.quaternion.setFromEuler(new THREE.Euler(shipRot.pitch, shipRot.yaw, 0, 'YXZ'));
                    const speed = (keys['ShiftLeft'] ? 1800 : 700) * delta;
                    if (keys['KeyW'] || keys['KeyZ']) ship.translateZ(-speed);
                    if (keys['KeyS']) ship.translateZ(speed * 0.5);

                    engineFlames.forEach((f, i) => {
                        const scale = keys['KeyW'] || keys['KeyZ'] ? 1.8 : 0.5;
                        f.scale.setScalar(scale + Math.sin(time * 10 + i) * 0.2);
                    });

                    // Camera follows ship but looks ahead (Third Person Shooter Style)
                    const camOffset = new THREE.Vector3(0, 150, 450).applyQuaternion(ship.quaternion); // Higher and further back
                    camera.position.lerp(ship.position.clone().add(camOffset), 0.1);

                    // Look at a point far in front of the ship to clear the view
                    const lookTarget = ship.position.clone().add(new THREE.Vector3(0, 20, -3000).applyQuaternion(ship.quaternion));
                    camera.lookAt(lookTarget);

                    // UPDATE SPACE COMBAT
                    updateSpaceEnemies(delta, time);
                    drawRadar();
                    updateQuest();

                    // HUD: Ship Integrity
                    const shipHpPercent = Math.max(0, (shipHealth / maxShipHealth) * 100);
                    document.getElementById('health-bar').style.width = shipHpPercent + "%";
                    document.getElementById('health-bar').style.backgroundColor = "#00aaff"; // Blue for Hull

                    // Simple interaction prompt for planets
                    planets.forEach(p => {
                        p.rotation.y += 0.001;
                        p.userData.clouds.rotation.y += 0.0015;
                        if (ship.position.distanceTo(p.position) < p.userData.size + 800) {
                            document.getElementById('prompt').innerText = "[E] ATTERRIR SUR " + p.userData.name;
                        } else if (document.getElementById('prompt').innerText.includes(p.userData.name)) {
                            document.getElementById('prompt').innerText = "";
                        }
                    });

                    // Keep ground enemies in stasis/idle
                    enemies.forEach(en => {
                        const distToPlayer = en.position.distanceTo(ship.position);
                        const distToHome = en.position.distanceTo(en.userData.home);

                        if (distToPlayer < 4000 && distToHome < 5000) {
                            en.lookAt(ship.position);
                            en.translateZ(-15);
                            if (time - en.userData.lastShot > 2.5) {
                                enemyShoot(en);
                                en.userData.lastShot = time;
                            }
                        } else {
                            en.position.x = en.userData.home.x + Math.sin(time * 0.3) * 1500;
                            en.position.z = en.userData.home.z + Math.cos(time * 0.3) * 1500;
                            en.lookAt(en.userData.home);
                        }
                    });

                } else {
                    camera.rotation.set(playerRot.pitch, playerRot.yaw, 0, 'YXZ');
                    const moveSpd = 350 * delta;
                    if (keys['KeyW'] || keys['KeyZ']) camera.translateZ(-moveSpd);
                    if (keys['KeyS']) camera.translateZ(moveSpd);
                    if (keys['KeyA'] || keys['KeyQ']) camera.translateX(-moveSpd);
                    if (keys['KeyD']) camera.translateX(moveSpd);

                    const tx = camera.position.x;
                    const tz = camera.position.z;
                    const ty = (Math.sin(tx / 500) * Math.cos(tz / 500) * 200) + (Math.sin(tx / 100) * 30);
                    camera.position.y = ty + 40;

                    document.getElementById('prompt').innerText = "";
                    if (camera.position.distanceTo(ship.position) < 200) {
                        document.getElementById('prompt').innerText = "[E] RETOUR AU VAISSEAU";
                    }

                    checkMissionObjectInteraction();
                }
            }
            if (composer) composer.render();
            else renderer.render(scene, camera);
        }

        init();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) composer.setSize(window.innerWidth, window.innerHeight);
        };

        function createTitanShip() {
            const shipGroup = new THREE.Group();

            // --- MATERIALS ---
            const metalTex = createMetallicTexture();
            const hullMat = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                map: metalTex,
                roughness: 0.4,
                metalness: 0.8,
                envMapIntensity: 1.2
            });

            const darkMat = new THREE.MeshStandardMaterial({
                color: 0x333333,
                map: metalTex,
                roughness: 0.6,
                metalness: 0.5
            });

            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00aaff,
                metalness: 0.1,
                roughness: 0.0,
                transmission: 0.8,
                transparent: true,
                opacity: 0.5
            });

            // SCALE FACTOR = 5

            // --- FUSELAGE ---
            const bodyGeo = new THREE.CylinderGeometry(6.0, 4.0, 30, 32);
            bodyGeo.rotateX(Math.PI / 2);
            const body = new THREE.Mesh(bodyGeo, hullMat);
            shipGroup.add(body);

            const noseGeo = new THREE.ConeGeometry(4.0, 20, 32);
            noseGeo.rotateX(-Math.PI / 2);
            const nose = new THREE.Mesh(noseGeo, hullMat);
            nose.position.z = -25;
            shipGroup.add(nose);

            const rearGeo = new THREE.BoxGeometry(15, 7.5, 20);
            const rear = new THREE.Mesh(rearGeo, darkMat);
            rear.position.z = 20;
            shipGroup.add(rear);

            // --- COCKPIT ---
            const cockpitGeo = new THREE.CapsuleGeometry(4.5, 12, 4, 16);
            cockpitGeo.rotateX(Math.PI / 2);
            const cockpit = new THREE.Mesh(cockpitGeo, glassMat);
            cockpit.position.set(0, 2.5, -5);
            cockpit.scale.set(1, 0.7, 1);
            shipGroup.add(cockpit);

            // --- WINGS ---
            const wingGeo = new THREE.BoxGeometry(50, 1.0, 25);
            const wings = new THREE.Mesh(wingGeo, hullMat);
            wings.position.set(0, 0, 5);
            shipGroup.add(wings);

            const tipGeo = new THREE.BoxGeometry(1.0, 7.5, 15);
            const leftTip = new THREE.Mesh(tipGeo, darkMat);
            leftTip.position.set(-25, 2.5, 5);
            shipGroup.add(leftTip);

            const rightTip = new THREE.Mesh(tipGeo, darkMat);
            rightTip.position.set(25, 2.5, 5);
            shipGroup.add(rightTip);

            const tailGeo = new THREE.BoxGeometry(1.0, 20, 15);
            const tail = new THREE.Mesh(tailGeo, hullMat);
            tail.position.set(0, 10, 22.5);
            shipGroup.add(tail);

            // --- ENGINES ---
            const engineGeo = new THREE.CylinderGeometry(4.0, 6.0, 20, 32);
            engineGeo.rotateX(Math.PI / 2);

            const leftEngine = new THREE.Mesh(engineGeo, darkMat);
            leftEngine.position.set(-15, 0, 15);
            shipGroup.add(leftEngine);

            const rightEngine = new THREE.Mesh(engineGeo, darkMat);
            rightEngine.position.set(15, 0, 15);
            shipGroup.add(rightEngine);

            // Engine Flames
            window.engineFlames = [];
            for (let i = 0; i < 2; i++) {
                const flame = new THREE.Mesh(new THREE.ConeGeometry(2.5, 35, 16), new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                }));
                flame.rotation.x = Math.PI / 2;
                flame.position.set(i === 0 ? -15 : 15, 0, 32.5);
                shipGroup.add(flame);
                window.engineFlames.push(flame);
            }

            // Navigation Lights
            const navLightGeo = new THREE.SphereGeometry(1.0, 16, 16);
            const redLight = new THREE.Mesh(navLightGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            redLight.position.set(-30, 2.0, 0);
            shipGroup.add(redLight);

            const greenLight = new THREE.Mesh(navLightGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            greenLight.position.set(30, 2.0, 0);
            shipGroup.add(greenLight);

            setInterval(() => {
                redLight.visible = !redLight.visible;
                greenLight.visible = !greenLight.visible;
            }, 1000);

            return shipGroup;
        }

        // --- GAMEPLAY V2 LOGIC ---

        // SHOP SYSTEM
        function toggleShop() {
            shopOpen = !shopOpen;
            const ui = document.getElementById('shop-ui');
            if (shopOpen) {
                ui.style.display = 'block';
                document.exitPointerLock();
                populateShop();
            } else {
                ui.style.display = 'none';
                if (!isLocked) document.body.requestPointerLock();
            }
        }

        function populateShop() {
            const items = [
                { id: 'laser', name: 'PLASMA OVERCHARGE', cost: 500, desc: 'Increases laser damage & count', level: upgrades.laserLevel },
                { id: 'damage', name: 'TITAN PLATING', cost: 800, desc: 'Increases Ship Hull HP (+500)', level: upgrades.armor },
                { id: 'speed', name: 'THRUSTER BOOST', cost: 400, desc: 'Increases flight speed by 20%', level: upgrades.speed }
            ];

            const grid = document.getElementById('shop-items');
            grid.innerHTML = '';
            document.getElementById('shop-credits').innerText = credits;

            items.forEach(item => {
                const div = document.createElement('div');
                div.style.border = '1px solid #333';
                div.style.padding = '10px';
                div.style.background = 'rgba(0,0,0,0.5)';

                div.innerHTML = `
                    <h3 style="margin: 0; color: #00f0ff;">${item.name} (Lvl ${item.level})</h3>
                    <p style="font-size: 0.8em; color: #ccc;">${item.desc}</p>
                    <button onclick="buyUpgrade('${item.id}', ${item.cost})" style="width: 100%; padding: 5px; background: #ffaa00; border: none; cursor: pointer; font-weight: bold; margin-top: 5px;">
                        BUY (${item.cost} CR)
                    </button>
                `;
                grid.appendChild(div);
            });
        }

        window.buyUpgrade = function (type, cost) {
            if (credits >= cost) {
                credits -= cost;
                document.getElementById('shop-credits').innerText = credits;
                document.getElementById('score').innerText = "CREDITS : " + credits; // Update Main HUD

                if (type === 'laser') upgrades.laserLevel++;
                else if (type === 'damage') {
                    upgrades.armor++;
                    maxShipHealth += 500;
                    shipHealth += 500;
                    showNotification("ARMOR UPGRADED!");
                }
                else if (type === 'speed') upgrades.speed++;

                populateShop(); // Refresh UI
                showNotification("UPGRADE PURCHASED!");
            } else {
                alert("NOT ENOUGH CREDITS!");
            }
        };

        window.addEventListener('keydown', e => {
            if (e.code === 'KeyB') toggleShop();
        });

        // SPACE COMBAT SYSTEM
        function spawnSpaceEnemy() {
            if (currentMode !== 'SPACE' || spaceEnemies.length > 5) return;

            // Enemy Ship Geometry (Simple but aggressive)
            const enemyGroup = new THREE.Group();

            // NEW PREDATOR CLASS DESIGN
            const matDark = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4, metalness: 0.9 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.3, metalness: 0.6, emissive: 0x330000 });
            const matGlow = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            // Main Hull - Sleek angular shape
            const hullGeo = new THREE.ConeGeometry(8, 60, 4);
            hullGeo.rotateX(Math.PI / 2);
            hullGeo.rotateZ(Math.PI / 4); // Diamond cross-section
            const hull = new THREE.Mesh(hullGeo, matDark);
            enemyGroup.add(hull);

            // Cockpit
            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 15), matRed);
            cockpit.position.set(0, 5, 0);
            enemyGroup.add(cockpit);

            // Forward Swept Wings
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(20, -10);
            wingShape.lineTo(40, 10); // Tip
            wingShape.lineTo(10, 5);
            wingShape.lineTo(0, 0);

            const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 2, bevelEnabled: false });
            wingGeo.rotateX(Math.PI / 2);

            const leftWing = new THREE.Mesh(wingGeo, matDark);
            leftWing.position.set(-5, 0, 5);
            leftWing.rotation.z = 0.2;
            enemyGroup.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo.clone(), matDark);
            rightWing.position.set(5, 0, 5);
            rightWing.rotation.z = -0.2;
            rightWing.scale.x = -1; // Mirror
            enemyGroup.add(rightWing);

            // Weapon Pods (Guns)
            const gunGeo = new THREE.CylinderGeometry(1, 1, 30);
            gunGeo.rotateX(Math.PI / 2);
            const leftGun = new THREE.Mesh(gunGeo, matRed);
            leftGun.position.set(-25, 0, 10);
            enemyGroup.add(leftGun);

            const rightGun = new THREE.Mesh(gunGeo, matRed);
            rightGun.position.set(25, 0, 10);
            enemyGroup.add(rightGun);

            // Engine glow
            const glow = new THREE.Mesh(new THREE.SphereGeometry(6), matGlow);
            glow.position.z = 30;
            glow.scale.set(1, 0.5, 1);
            enemyGroup.add(glow);

            // Spawn random distance
            const angle = Math.random() * Math.PI * 2;
            const dist = 4000 + Math.random() * 2000;
            enemyGroup.position.set(
                ship.position.x + Math.cos(angle) * dist,
                ship.position.y + (Math.random() - 0.5) * 1000,
                ship.position.z + Math.sin(angle) * dist
            );

            enemyGroup.userData = { hp: 5, lastShot: 0 };
            scene.add(enemyGroup);
            spaceEnemies.push(enemyGroup);

            // Removed showNotification here as requested - Radar will show them
        }

        const radarCanvas = document.getElementById('radar-canvas');
        const radarCtx = radarCanvas.getContext('2d');

        function drawRadar() {
            if (isInCinematic) {
                document.getElementById('radar-container').style.display = 'none';
                return;
            }
            document.getElementById('radar-container').style.display = 'block';

            const w = radarCanvas.width;
            const h = radarCanvas.height;
            const center = { x: w / 2, y: h / 2 };

            // Adaptive Range: 8000 in Space, 2000 on Planets
            const range = (currentMode === 'SPACE') ? 8000 : 3000;

            // Clear
            radarCtx.clearRect(0, 0, w, h);

            // Background circles
            radarCtx.strokeStyle = (currentMode === 'SPACE') ? "rgba(0, 240, 255, 0.2)" : "rgba(100, 255, 100, 0.2)";
            radarCtx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                radarCtx.beginPath();
                radarCtx.arc(center.x, center.y, (w / 2) * (i / 3), 0, Math.PI * 2);
                radarCtx.stroke();
            }

            // Crosshair
            radarCtx.strokeStyle = (currentMode === 'SPACE') ? "#00f0ff" : "#44ff44";
            radarCtx.beginPath();
            radarCtx.moveTo(center.x - 10, center.y); radarCtx.lineTo(center.x + 10, center.y);
            radarCtx.moveTo(center.x, center.y - 10); radarCtx.lineTo(center.x, center.y + 10);
            radarCtx.stroke();

            // Draw Entities Helper
            const drawDot = (pos, color, size = 3) => {
                const playerPos = (currentMode === 'SPACE') ? ship.position : camera.position;
                const playerYaw = (currentMode === 'SPACE') ? shipRot.yaw : playerRot.yaw;

                const relX = pos.x - playerPos.x;
                const relZ = pos.z - playerPos.z;

                // Rotate based on player yaw
                const cos = Math.cos(-playerYaw);
                const sin = Math.sin(-playerYaw);
                const rotX = relX * cos - relZ * sin;
                const rotZ = relX * sin + relZ * cos;

                if (Math.abs(rotX) < range && Math.abs(rotZ) < range) {
                    const px = center.x + (rotX / range) * (w / 2);
                    const py = center.y + (rotZ / range) * (h / 2);

                    radarCtx.fillStyle = color;
                    radarCtx.beginPath();
                    radarCtx.arc(px, py, size, 0, Math.PI * 2);
                    radarCtx.fill();

                    if (size > 3) { // Glow for important objects
                        radarCtx.shadowBlur = 8;
                        radarCtx.shadowColor = color;
                        radarCtx.stroke();
                        radarCtx.shadowBlur = 0;
                    }
                }
            };

            if (currentMode === 'SPACE') {
                // Draw Space Objects
                planets.forEach(p => drawDot(p.position, p.userData.color || "#ffffff", 6));
                spaceEnemies.forEach(e => drawDot(e.position, "#ff0000", 3));
                if (warpGate) drawDot(warpGate.position, "#ffaa00", 8);
            } else {
                // Draw Planet Objectives (Gems, Towers, Monoliths)
                missionObjects.forEach(obj => {
                    let dotColor = "#ffff00"; // Default yellow for objectives
                    if (obj.userData.type === 'collectible') dotColor = "#ffaa00";
                    if (obj.userData.type === 'destroyable') dotColor = "#ff3300";
                    if (obj.userData.type === 'scannable') dotColor = "#00ff00";

                    drawDot(obj.position, dotColor, 4);
                });
                // Also show enemies on planet radar (Red)
                enemies.forEach(e => {
                    if (e.visible) drawDot(e.position, "#ff0000", 2);
                });
            }

            // Direction indicator
            radarCtx.strokeStyle = radarCtx.strokeStyle;
            radarCtx.beginPath();
            radarCtx.moveTo(center.x, center.y);
            radarCtx.lineTo(center.x, center.y - 30);
            radarCtx.stroke();
        }

        function updateQuest() {
            const stage = QUEST_STAGES[questStage];
            if (!stage) return;

            // Check completion
            let completed = false;
            switch (questStage) {
                case 0: if (credits >= stage.goal) completed = true; break;
                case 1: if (upgrades.armor > 1) completed = true; break;
                case 2: if (specialItems.cipherFound) completed = true; break;
                case 3: if (specialItems.powerCores >= stage.goal) completed = true; break;
                case 4: if (credits >= stage.goal && ship.position.distanceTo(warpGate.position) < 1000) {
                    specialItems.gateRepaired = true;
                    completed = true;
                } break;
            }

            if (completed) {
                questStage++;
                showNotification("MISSION MISE Ã€ JOUR : " + stage.title);
                if (questStage >= QUEST_STAGES.length) {
                    showNotification("ODYSSÃ‰E TERMINÃ‰E ! TOUT EST POSSIBLE.");
                    // Optional: Final celebration cinematic
                }
            }

            // Update UI
            document.getElementById('objective-title').innerText = "OBJECTIF " + (questStage + 1) + " : " + stage.title;
            document.getElementById('objective-desc').innerText = stage.desc;

            // Handle special logic
            if (questStage === 4 && !warpGate) {
                createWarpGate();
            }
        }

        function createWarpGate() {
            const gateGroup = new THREE.Group();
            const ringGeo = new THREE.TorusGeometry(1200, 100, 16, 100); // Massive gate
            const ringMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x00f0ff,
                emissiveIntensity: 0.5
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            gateGroup.add(ring);

            // Event horizon effect
            const coreGeo = new THREE.SphereGeometry(1100, 32, 32);
            const coreMat = new THREE.MeshBasicMaterial({
                color: 0x001133,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const core = new THREE.Mesh(coreGeo, coreMat);
            core.scale.z = 0.1;
            gateGroup.add(core);

            gateGroup.position.set(5000, 0, -25000);
            scene.add(gateGroup);
            warpGate = gateGroup;

            showNotification("âš ï¸ STRUCTURE MASSIVE DÃ‰TECTÃ‰E DANS LE SECTEUR KAPPA");
        }

        function updateSpaceEnemies(delta, time) {
            spaceEnemies.forEach((en, i) => {
                // Chase Player
                const dir = new THREE.Vector3().subVectors(ship.position, en.position).normalize();
                en.position.addScaledVector(dir, 600 * delta); // Speed
                en.lookAt(ship.position);

                // Shoot at player
                if (time - en.userData.lastShot > 2.0 && en.position.distanceTo(ship.position) < 3000) {
                    en.userData.lastShot = time;
                    enemySpaceShoot(en);
                }
            });

            // Random spawns - Reduced frequency (0.005 -> 0.001)
            if (Math.random() < 0.001) spawnSpaceEnemy();
        }

        function enemySpaceShoot(enemy) {
            const laser = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 100), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            laser.geometry.rotateX(Math.PI / 2);
            laser.position.copy(enemy.position);
            laser.lookAt(ship.position);
            scene.add(laser);

            const dir = new THREE.Vector3().subVectors(ship.position, enemy.position).normalize();

            let frames = 0;
            function move() {
                laser.position.addScaledVector(dir, 100); // Fast lasers
                if (currentMode === 'SPACE' && laser.position.distanceTo(ship.position) < 200) { // Hitbox
                    takeShipDamage(50);
                    scene.remove(laser);
                    return;
                }
                if (frames++ < 100) requestAnimationFrame(move);
                else scene.remove(laser);
            } move();
        }

        function takeShipDamage(amount) {
            shipHealth -= amount;
            // Visual feedback (screen shake or red flash could be added here)
            document.getElementById('damage-overlay').style.backgroundColor = "rgba(255,0,0,0.5)";
            setTimeout(() => { document.getElementById('damage-overlay').style.backgroundColor = "transparent"; }, 200);

            if (shipHealth <= 0) {
                alert("CRITICAL FAILURE! SHIP DESTROYED.");
                location.reload();
            }
        }

        function spawnAmbush(pos) {
            showNotification("âš ï¸ AMBUSH DETECTED! ELITE SENTINELS INCOMING!");

            for (let i = 0; i < 3; i++) {
                const group = new THREE.Group();
                // Elite Appearance: Black and Red, Spiky
                const hull = new THREE.Mesh(
                    new THREE.ConeGeometry(2, 6, 4),
                    new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.9 })
                );
                hull.rotateX(Math.PI / 2);

                const spikes = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 1, 4),
                    new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 })
                );

                group.add(hull, spikes);

                // Spawn nearby
                const angle = Math.random() * Math.PI * 2;
                group.position.set(
                    pos.x + Math.cos(angle) * 50,
                    pos.y + 20,
                    pos.z + Math.sin(angle) * 50
                );

                group.userData = { hp: 50, home: group.position.clone(), lastShot: 0 }; // Elite HP
                scene.add(group);
                enemies.push(group);
            }
        }

        function spawnCipher() {
            const cipher = new THREE.Mesh(
                new THREE.IcosahedronGeometry(20, 0),
                new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 })
            );
            cipher.position.set((Math.random() - 0.5) * 2000, 100, (Math.random() - 0.5) * 2000);
            cipher.userData.type = 'cipher';
            planetEnvironment.add(cipher);
            missionObjects.push(cipher);
            showNotification("DÃ‰TECTION : CHIFFRE ANCIEN DANS LA ZONE !");
        }

        function spawnPowerCores(count) {
            for (let i = 0; i < count; i++) {
                const core = new THREE.Mesh(
                    new THREE.BoxGeometry(30, 30, 30),
                    new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 1 })
                );
                core.position.set((Math.random() - 0.5) * 4000, 50, (Math.random() - 0.5) * 4000);
                core.userData.type = 'powerCore';
                planetEnvironment.add(core);
                missionObjects.push(core);
            }
            showNotification(`DÃ‰TECTION : ${count} NOYAUX D'Ã‰NERGIE DESSÃ‰MINÃ‰S !`);
        }

        function tryInteract() {
            if (isInCinematic) return;

            if (currentMode === 'SPACE') {
                // Check if near planet
                planets.forEach(p => {
                    if (ship.position.distanceTo(p.position) < p.userData.size + 1000) {
                        startLanding(p);
                    }
                });

                // Check Warp Gate
                if (warpGate && questStage === 4) {
                    if (ship.position.distanceTo(warpGate.position) < 1500) {
                        if (credits >= 5000) {
                            credits -= 5000;
                            specialItems.gateRepaired = true;
                            showNotification("PORTE ACTIVÃ‰E ! SAUT QUANTIQUE EN COURS...");
                            // Final Victory logic
                            setTimeout(() => {
                                showNotification("VICTOIRE ! VOUS AVEZ REJOINT LA TERRE.");
                                alert("MISSION ACCOMPLIE ! FÃ©licitations Commandant Ahmed.");
                                location.reload();
                            }, 3000);
                        } else {
                            showNotification("PAS ASSEZ DE CRÃ‰DITS (5000 REQUIS)");
                        }
                    }
                }
            } else {
                // Planet Mode
                let interacted = false;
                missionObjects.forEach((obj, index) => {
                    const dist = camera.position.distanceTo(obj.position);
                    if (dist < 300) {
                        interacted = true;

                        // NEW INTERACTIONS
                        if (obj.userData.type === 'vent' && !obj.userData.cooled) {
                            obj.userData.cooled = true;
                            obj.remove(obj.userData.steam);
                            obj.material.color.set(0x111111);
                            showNotification("Ã‰VENT REFROIDI !");
                            collectedItems++;
                            updateMissionProgress();
                        }
                        else if (obj.userData.type === 'terminal' && !obj.userData.hacked) {
                            obj.userData.hacked = true;
                            obj.children[1].material.color.set(0xff0000); // Red screen
                            showNotification("TERMINAL PIRATÃ‰ !");
                            collectedItems++;
                            updateMissionProgress();
                        }
                        else if (obj.userData.type === 'pylon' && !obj.userData.active) {
                            obj.userData.active = true;
                            obj.material.emissive = new THREE.Color(0x00f0ff);
                            obj.material.emissiveIntensity = 2;
                            showNotification("PYLÃ”NE ACTIVÃ‰ !");
                            collectedItems++;
                            updateMissionProgress();
                        }
                        // QUEST ITEMS
                        else if (obj.userData.type === 'cipher' && questStage === 2) {
                            specialItems.cipherFound = true;
                            showNotification("CHIFFRE RÃ‰CUPÃ‰RÃ‰ !");
                            planetEnvironment.remove(obj);
                            missionObjects.splice(index, 1);
                            collectedItems++;
                            updateMissionProgress();
                            updateQuest();
                        }
                        else if (obj.userData.type === 'powerCore' && questStage === 3) {
                            specialItems.powerCores++;
                            showNotification(`NOYAU RÃ‰CUPÃ‰RÃ‰ (${specialItems.powerCores}/5)`);
                            planetEnvironment.remove(obj);
                            missionObjects.splice(index, 1);
                            collectedItems++;
                            updateMissionProgress();
                            updateQuest();
                        }
                        // LEGACY/MISC
                        else if (obj.userData.type === 'collectible') {
                            collectedItems++;
                            credits += 100;
                            showNotification("OBJET RÃ‰CUPÃ‰RÃ‰");
                            planetEnvironment.remove(obj);
                            missionObjects.splice(index, 1);
                            updateMissionProgress();
                        }
                        else if (obj.userData.type === 'scannable' && !obj.userData.scanned) {
                            obj.userData.scanned = true;
                            showNotification("SCAN TERMINÃ‰");
                            collectedItems++;
                            updateMissionProgress();
                        }
                    }
                });

                // Exit planet check if no interaction
                if (!interacted && camera.position.length() > 6000) {
                    exitPlanet();
                }
            }
        }
    </script>
</body>

</html>
